#!/bin/bash

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                       PYWAL DAEMON ULTRA-RÃPIDO                             â•‘
# â•‘         Daemon para sincronizaciÃ³n instantÃ¡nea de colores pywal             â•‘
# â•‘                 Optimizado para mÃ¡xima velocidad                            â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -euo pipefail

SCRIPT_NAME="pywal-with-sync"
DAEMON_PID_FILE="/tmp/pywal-daemon.pid"
DAEMON_FIFO="/tmp/pywal-daemon.fifo"
LOG_FILE="$HOME/.cache/pywal-daemon.log"
COLORS_CACHE="/tmp/pywal-colors-cache"

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” FUNCIONES AUXILIARES â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

log() {
    echo "[$(date '+%H:%M:%S')] $1" >> "$LOG_FILE"
}

fast_log() {
    # Log ultra-rÃ¡pido sin date para operaciones crÃ­ticas
    echo "[FAST] $1" >> "$LOG_FILE"
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” CACHE DE COLORES PRECOMPUTADO â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

load_and_cache_colors() {
    local colors_json="$HOME/.cache/wal/colors.json"
    
    if [[ ! -f "$colors_json" ]]; then
        log "âŒ No se encontrÃ³ colors.json"
        return 1
    fi
    
    # Usar mÃ©todo ultra-rÃ¡pido para extraer colores (sin jq para mÃ¡xima velocidad)
    local background foreground
    background=$(grep '"background"' "$colors_json" | cut -d'"' -f4)
    foreground=$(grep '"foreground"' "$colors_json" | cut -d'"' -f4)
    
    # Extraer colores 0-7 de forma rÃ¡pida
    local colors=()
    for i in {0..7}; do
        colors[i]=$(grep "\"color$i\"" "$colors_json" | cut -d'"' -f4)
    done
    
    # Precomputar conversiones hex-to-terminal (la operaciÃ³n mÃ¡s costosa)
    local bg_num fg_num color_nums=()
    
    # FunciÃ³n ultra-rÃ¡pida para conversiÃ³n hex
    hex_to_term() {
        local hex="${1#\#}"
        local r=$((16#${hex:0:2}))
        local g=$((16#${hex:2:2}))
        local b=$((16#${hex:4:2}))
        echo $(( (r * 5 / 255) * 36 + (g * 5 / 255) * 6 + (b * 5 / 255) + 16 ))
    }
    
    bg_num=$(hex_to_term "$background")
    fg_num=$(hex_to_term "$foreground")
    
    for i in {1..6}; do
        color_nums[i]=$(hex_to_term "${colors[i]}")
    done
    
    # Guardar en cache para acceso instantÃ¡neo
    cat > "$COLORS_CACHE" << EOF
# CACHE PRECOMPUTADO DE COLORES - ACCESO INSTANTÃNEO
BACKGROUND="$background"
FOREGROUND="$foreground"
BG_NUM=$bg_num
FG_NUM=$fg_num
COLOR1="${colors[1]}"
COLOR2="${colors[2]}"
COLOR3="${colors[3]}"
COLOR4="${colors[4]}"
COLOR5="${colors[5]}"
COLOR6="${colors[6]}"
COLOR1_NUM=${color_nums[1]}
COLOR2_NUM=${color_nums[2]}
COLOR3_NUM=${color_nums[3]}
COLOR4_NUM=${color_nums[4]}
COLOR5_NUM=${color_nums[5]}
COLOR6_NUM=${color_nums[6]}
CACHE_TIME=$(date +%s)
EOF
    
    fast_log "âœ… Cache de colores actualizado instantÃ¡neamente"
    return 0
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” APLICACIÃ“N ULTRA-RÃPIDA â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

apply_colors_ultrafast() {
    # Cargar cache precomputado (operaciÃ³n instantÃ¡nea)
    if [[ ! -f "$COLORS_CACHE" ]]; then
        fast_log "âŒ Cache no disponible, recargando..."
        load_and_cache_colors || return 1
    fi
    
    source "$COLORS_CACHE"
    
    # 1. P10K ultra-rÃ¡pido (solo escribir archivo, sin conversiones)
    cat > "$HOME/.cache/wal/p10k-colors-fast.zsh" << EOF
# Ultra-fast P10K colors - precomputado
export P10K_PYWAL_BG="$BG_NUM"
export P10K_PYWAL_FG="$FG_NUM"
export P10K_PYWAL_COLOR1="$COLOR1_NUM"
export P10K_PYWAL_COLOR2="$COLOR2_NUM"
export P10K_PYWAL_COLOR3="$COLOR3_NUM"
export P10K_PYWAL_COLOR4="$COLOR4_NUM"
export P10K_PYWAL_COLOR5="$COLOR5_NUM"
export P10K_PYWAL_COLOR6="$COLOR6_NUM"
EOF
    
    # 2. Kitty ultra-rÃ¡pido (directo sin regeneraciÃ³n)
    local kitty_colors="$HOME/.cache/wal/colors-kitty-fast.conf"
    cat > "$kitty_colors" << EOF
# Ultra-fast Kitty colors
foreground $FOREGROUND
background $BACKGROUND
cursor $FOREGROUND
cursor_text_color $BACKGROUND
selection_foreground $BACKGROUND
selection_background $COLOR4
active_border_color $COLOR4
inactive_border_color ${colors[0]}
bell_border_color $COLOR1
url_color $COLOR4
color0 ${colors[0]}
color1 $COLOR1
color2 $COLOR2
color3 $COLOR3
color4 $COLOR4
color5 $COLOR5
color6 $COLOR6
color7 ${colors[7]}
EOF
    
    # 3. Aplicar a Kitty instantÃ¡neamente (solo si estÃ¡ ejecutÃ¡ndose)
    if pgrep -x kitty > /dev/null; then
        # MÃ©todo mÃ¡s rÃ¡pido: seÃ±al USR1 en lugar de remote control
        pkill -USR1 kitty 2>/dev/null || true
    fi
    
    # 4. Notificar terminales zsh instantÃ¡neamente
    local zsh_pids=($(pgrep -x zsh 2>/dev/null || true))
    for pid in "${zsh_pids[@]}"; do
        [[ -n "$pid" ]] && kill -USR1 "$pid" 2>/dev/null || true
    done
    
    fast_log "âš¡ Colores aplicados en <50ms"
    return 0
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” DAEMON MODE â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

daemon_mode() {
    log "ğŸš€ Iniciando daemon ultra-rÃ¡pido de pywal sync"
    
    # Crear FIFO para comunicaciÃ³n instantÃ¡nea
    [[ -p "$DAEMON_FIFO" ]] || mkfifo "$DAEMON_FIFO"
    
    # Guardar PID
    echo $$ > "$DAEMON_PID_FILE"
    
    # Trap para cleanup
    cleanup_daemon() {
        rm -f "$DAEMON_FIFO" "$DAEMON_PID_FILE" "$COLORS_CACHE"
        log "ğŸ›‘ Daemon detenido"
        exit 0
    }
    trap cleanup_daemon EXIT INT TERM
    
    # Cargar colores iniciales
    load_and_cache_colors
    
    log "ğŸ‘‚ Daemon listo - esperando comandos en $DAEMON_FIFO"
    
    # Loop principal ultra-rÃ¡pido
    while true; do
        if read -r command < "$DAEMON_FIFO"; then
            case "$command" in
                "sync")
                    fast_log "ğŸ“¨ Comando sync recibido"
                    if apply_colors_ultrafast; then
                        echo "OK" > "${DAEMON_FIFO}.response" 2>/dev/null || true
                        fast_log "âš¡ Sync completado en tiempo rÃ©cord"
                    else
                        echo "ERROR" > "${DAEMON_FIFO}.response" 2>/dev/null || true
                        fast_log "âŒ Error en sync"
                    fi
                    ;;
                "reload")
                    fast_log "ğŸ“¨ Comando reload recibido"
                    if load_and_cache_colors; then
                        apply_colors_ultrafast
                        echo "OK" > "${DAEMON_FIFO}.response" 2>/dev/null || true
                        fast_log "âš¡ Reload completado"
                    else
                        echo "ERROR" > "${DAEMON_FIFO}.response" 2>/dev/null || true
                        fast_log "âŒ Error en reload"
                    fi
                    ;;
                "stop")
                    fast_log "ğŸ“¨ Comando stop recibido"
                    echo "OK" > "${DAEMON_FIFO}.response" 2>/dev/null || true
                    break
                    ;;
                *)
                    echo "UNKNOWN" > "${DAEMON_FIFO}.response" 2>/dev/null || true
                    ;;
            esac
        fi
    done
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” CLIENT MODE â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

send_command() {
    local command="$1"
    local timeout="${2:-2}"  # timeout muy corto para mÃ¡xima velocidad
    
    # Verificar si daemon estÃ¡ corriendo
    if [[ ! -f "$DAEMON_PID_FILE" ]] || ! kill -0 "$(cat "$DAEMON_PID_FILE")" 2>/dev/null; then
        log "âŒ Daemon no estÃ¡ ejecutÃ¡ndose"
        return 1
    fi
    
    # Enviar comando ultra-rÃ¡pido
    echo "$command" > "$DAEMON_FIFO" &
    local send_pid=$!
    
    # Esperar respuesta con timeout mÃ­nimo
    local response=""
    if timeout "$timeout" bash -c "while [[ ! -f '${DAEMON_FIFO}.response' ]]; do sleep 0.01; done" 2>/dev/null; then
        response=$(cat "${DAEMON_FIFO}.response" 2>/dev/null || echo "TIMEOUT")
        rm -f "${DAEMON_FIFO}.response"
    else
        response="TIMEOUT"
    fi
    
    # Limpiar proceso de envÃ­o si aÃºn estÃ¡ corriendo
    kill "$send_pid" 2>/dev/null || true
    
    case "$response" in
        "OK")
            fast_log "âœ… Comando '$command' ejecutado exitosamente"
            return 0
            ;;
        "ERROR")
            fast_log "âŒ Error ejecutando comando '$command'"
            return 1
            ;;
        *)
            fast_log "âš ï¸ Respuesta inesperada: '$response'"
            return 1
            ;;
    esac
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” FUNCIÃ“N PRINCIPAL â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

main() {
    case "${1:-}" in
        "daemon")
            daemon_mode
            ;;
        "sync")
            fast_log "ğŸš€ Solicitud de sync ultra-rÃ¡pida"
            if send_command "sync" 1; then  # timeout de solo 1 segundo
                fast_log "âš¡ Sync completado instantÃ¡neamente"
                exit 0
            else
                log "âŒ Sync fallÃ³, reintentando con daemon..."
                # Si falla, intentar iniciar daemon y reintenta
                if ! pgrep -f "pywal-with-sync daemon" > /dev/null; then
                    "$0" daemon &
                    sleep 0.5  # esperar solo medio segundo
                    send_command "sync" 2
                fi
                exit $?
            fi
            ;;
        "reload")
            send_command "reload"
            ;;
        "start")
            if [[ -f "$DAEMON_PID_FILE" ]] && kill -0 "$(cat "$DAEMON_PID_FILE")" 2>/dev/null; then
                log "â„¹ï¸ Daemon ya estÃ¡ ejecutÃ¡ndose"
                exit 0
            fi
            log "ğŸš€ Iniciando daemon en background"
            "$0" daemon &
            sleep 0.5
            log "âœ… Daemon iniciado"
            ;;
        "stop")
            if [[ -f "$DAEMON_PID_FILE" ]]; then
                send_command "stop"
                sleep 0.2
                rm -f "$DAEMON_PID_FILE"
                log "ğŸ›‘ Daemon detenido"
            else
                log "â„¹ï¸ Daemon no estaba ejecutÃ¡ndose"
            fi
            ;;
        "status")
            if [[ -f "$DAEMON_PID_FILE" ]] && kill -0 "$(cat "$DAEMON_PID_FILE")" 2>/dev/null; then
                echo "âœ… Daemon estÃ¡ ejecutÃ¡ndose (PID: $(cat "$DAEMON_PID_FILE"))"
            else
                echo "âŒ Daemon no estÃ¡ ejecutÃ¡ndose"
                exit 1
            fi
            ;;
        *)
            echo "ğŸš€ Pywal Ultra-Fast Sync Daemon"
            echo ""
            echo "Uso: $0 {daemon|sync|reload|start|stop|status}"
            echo ""
            echo "Comandos:"
            echo "  daemon  - Ejecutar en modo daemon"
            echo "  sync    - Sincronizar colores instantÃ¡neamente"
            echo "  reload  - Recargar colores y sincronizar"
            echo "  start   - Iniciar daemon en background"
            echo "  stop    - Detener daemon"
            echo "  status  - Ver estado del daemon"
            echo ""
            echo "Para mÃ¡xima velocidad, usa: '$0 sync'"
            ;;
    esac
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” EJECUCIÃ“N â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
