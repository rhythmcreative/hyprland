#!/bin/bash

# Script ultra-optimizado: Selector de wallpaper + SincronizaciÃ³n instantÃ¡nea
# SOLO UN REINICIO DE WAYBAR - MÃXIMA VELOCIDAD

# Variables
WALLPAPER_DIR="$HOME/Pictures/Wallpapers"
CACHE_DIR="$HOME/.cache/wallpaper-previews"
TEMP_DIR="/tmp/rofi-wallpaper-$$"
LOG_FILE="/tmp/wallpaper-ultra-sync.log"

# Logging rÃ¡pido
log() {
    echo "$(date '+%H:%M:%S') - $1" >> "$LOG_FILE"
}

# Crear directorios
mkdir -p "$CACHE_DIR" "$TEMP_DIR"

# Limpiar al salir
cleanup() {
    if pgrep -x waybar > /dev/null; then
        pkill -SIGUSR2 waybar 2>/dev/null || true
    fi
    rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

log "ğŸš€ INICIO - Selector ultra-optimizado"

# Verificaciones rÃ¡pidas
if [[ ! -d "$WALLPAPER_DIR" ]]; then
    notify-send "âŒ Error" "Directorio $WALLPAPER_DIR no encontrado" -u critical
    exit 1
fi

for dep in convert wal swww rofi; do
    if ! command -v "$dep" > /dev/null 2>&1; then
        notify-send "âŒ Error" "$dep no estÃ¡ instalado" -u critical
        exit 1
    fi
done

# Buscar imÃ¡genes
cd "$WALLPAPER_DIR" || exit 1
shopt -s nullglob
images=(*.{jpg,jpeg,png,gif,webp,bmp})

if [[ ${#images[@]} -eq 0 ]]; then
    notify-send "âŒ Error" "No se encontraron imÃ¡genes vÃ¡lidas" -u critical
    exit 1
fi

# Ocultar waybar SOLO una vez
if pgrep -x waybar > /dev/null; then
    pkill -SIGUSR1 waybar 2>/dev/null || true
    log "ğŸ‘ï¸ Waybar oculto"
fi

# Generar opciones para rofi (paralelo)
options=""
valid_images=()

for img in "${images[@]}"; do
    [[ ! -f "$img" ]] && continue
    
    clean_name="${img%.*}"
    preview_file="$CACHE_DIR/preview_${clean_name}.png"
    
    # Generar preview si no existe (optimizado)
    if [[ ! -f "$preview_file" ]]; then
        if [[ "$img" == *.gif ]]; then
            convert "$img[0]" -resize "200x150^" -gravity center -extent "200x150" "$preview_file" 2>/dev/null &
        else
            convert "$img" -resize "200x150^" -gravity center -extent "200x150" "$preview_file" 2>/dev/null &
        fi
    fi
    
    valid_images+=("$img")
    options+="$clean_name\0icon\x1f$preview_file\n"
done

# Esperar a que terminen los procesos de conversiÃ³n
wait

# Filtrar opciones vÃ¡lidas
final_options=""
final_images=()
for img in "${valid_images[@]}"; do
    clean_name="${img%.*}"
    preview_file="$CACHE_DIR/preview_${clean_name}.png"
    if [[ -f "$preview_file" ]]; then
        final_images+=("$img")
        final_options+="$clean_name\0icon\x1f$preview_file\n"
    fi
done

if [[ ${#final_images[@]} -eq 0 ]]; then
    notify-send "âŒ Error" "No se pudieron generar previews" -u critical
    exit 1
fi

# Crear archivo para rofi
options_file="$TEMP_DIR/options"
printf "$final_options" > "$options_file"

# Mostrar selector
log "ğŸ¯ Mostrando selector"
theme_file="$HOME/HyprNova/.config/rofi/themes/wallpaper-select.rasi"

selected=$(cat "$options_file" | rofi -dmenu -i \
    -theme "$theme_file" \
    -p "ğŸ–¼ï¸ Seleccionar Wallpaper" \
    -show-icons \
    -markup-rows \
    -no-custom)

[[ -z "$selected" ]] && exit 0

# Buscar archivo seleccionado
selected_file=""
for img in "${final_images[@]}"; do
    if [[ "${img%.*}" == "$selected" ]]; then
        selected_file="$WALLPAPER_DIR/$img"
        break
    fi
done

if [[ -z "$selected_file" ]] || [[ ! -f "$selected_file" ]]; then
    notify-send "âŒ Error" "Archivo no encontrado: $selected" -u critical
    exit 1
fi

log "ğŸ¨ Aplicando: $selected_file"

# PROCESO OPTIMIZADO - TODO EN PARALELO
{
    # Aplicar wallpaper
    notify-send "ğŸ¨ Aplicando Wallpaper" "$selected" -t 1500 &
    swww img "$selected_file" --transition-type grow --transition-pos "0.9,0.1" --transition-duration 1.2 &
    
    # Guardar wallpaper actual
    echo "$selected_file" > ~/.cache/current-wallpaper
    
    # Aplicar pywal (proceso mÃ¡s lento)
    if [[ "${selected_file,,}" == *.gif ]]; then
        gif_frame_temp="/tmp/wal_gif_$$.png"
        convert "$selected_file[0]" "$gif_frame_temp" 2>/dev/null
        wal -i "$gif_frame_temp" -n >/dev/null 2>&1 &
        WAL_PID=$!
        rm -f "$gif_frame_temp" 2>/dev/null || true &
    else
        wal -i "$selected_file" -n >/dev/null 2>&1 &
        WAL_PID=$!
    fi
    
    log "ğŸ¨ Pywal iniciado en background (PID: $WAL_PID)"
}

# Esperar solo a pywal (crÃ­tico para colores)
wait $WAL_PID
log "âœ… Pywal completado"

# Aplicar cambios a Hyprland
hyprctl reload >/dev/null 2>&1 || true &

# SINCRONIZACIÃ“N WAYBAR ULTRA-RÃPIDA (una sola vez)
log "âš¡ SincronizaciÃ³n waybar ultra-rÃ¡pida"

# Preparar colores INMEDIATAMENTE
if [[ -f "$HOME/.cache/wal/colors.sh" ]]; then
    source "$HOME/.cache/wal/colors.sh"
    
    waybar_config_dir="$HOME/.config/waybar"
    
    # Generar CSS instantÃ¡neamente
    cat > "$waybar_config_dir/colors-pywal.css" << EOF
@define-color background ${background};
@define-color foreground ${foreground};
@define-color cursor ${cursor};
@define-color color0 ${color0};
@define-color color1 ${color1};
@define-color color2 ${color2};
@define-color color3 ${color3};
@define-color color4 ${color4};
@define-color color5 ${color5};
@define-color color6 ${color6};
@define-color color7 ${color7};
@define-color color8 ${color8};
@define-color color9 ${color9};
@define-color color10 ${color10};
@define-color color11 ${color11};
@define-color color12 ${color12};
@define-color color13 ${color13};
@define-color color14 ${color14};
@define-color color15 ${color15};
EOF
    
    # Aplicar style optimizado si existe
    if [[ -f "$waybar_config_dir/style-pywal.css" ]]; then
        cp "$waybar_config_dir/style-pywal.css" "$waybar_config_dir/style.css"
    fi
    
    log "ğŸ’¾ CSS actualizado instantÃ¡neamente"
fi

# REINICIO ÃšNICO E INMEDIATO DE WAYBAR
waybar_pids=$(pgrep -x waybar)
pid_count=$(echo "$waybar_pids" | wc -w)

log "ğŸ”„ ÃšNICO REINICIO waybar (instancias: $pid_count)"

if [[ $pid_count -eq 1 ]]; then
    # UNA INSTANCIA - Recarga instantÃ¡nea con seÃ±al
    if kill -USR2 $waybar_pids 2>/dev/null; then
        log "âš¡ Waybar recargado INSTANTÃNEAMENTE con USR2"
    else
        # Fallback - reinicio rÃ¡pido
        kill -TERM $waybar_pids 2>/dev/null
        sleep 0.8
        waybar &
        log "ğŸš€ Waybar reiniciado (fallback rÃ¡pido)"
    fi
elif [[ $pid_count -gt 1 ]]; then
    # MÃšLTIPLES INSTANCIAS - Limpieza rÃ¡pida
    kill -TERM $waybar_pids 2>/dev/null
    sleep 1
    pkill -9 waybar 2>/dev/null || true
    waybar &
    log "ğŸ§¹ MÃºltiples instancias limpiadas y reiniciado"
else
    # NO HAY WAYBAR - Inicio inmediato
    waybar &
    log "ğŸš€ Waybar iniciado desde cero"
fi

# Para GIFs - restaurar animaciÃ³n en background
if [[ "${selected_file,,}" == *.gif ]]; then
    {
        sleep 1.5
        if ! pgrep -x "swww-daemon" > /dev/null; then
            swww-daemon --format xrgb &
            sleep 1.5
        fi
        swww img "$selected_file" --transition-type none --transition-duration 0.1 >/dev/null 2>&1 || true
        log "ğŸ¬ GIF animaciÃ³n restaurada"
    } &
fi

log "ğŸ‰ PROCESO COMPLETADO - Una sola operaciÃ³n de waybar"
notify-send "âœ… Ultra-Sync Completo" "Wallpaper y waybar sincronizados instantÃ¡neamente" -t 2000 &
