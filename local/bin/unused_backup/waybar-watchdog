#!/bin/bash

# Waybar Watchdog - Monitorea y reinicia Waybar autom√°ticamente
# Se ejecuta como servicio en segundo plano

LOCK_FILE="/tmp/waybar-watchdog.lock"
LOG_FILE="$HOME/.cache/waybar-watchdog.log"
CHECK_INTERVAL=30  # segundos entre verificaciones (menos agresivo)
CONSECUTIVE_FAILURES=0  # Contador de fallos consecutivos
MAX_FAILURES_BEFORE_RESTART=3  # Fallos consecutivos antes de reiniciar
WALLPAPER_LOCK_FILES=("/tmp/stable-wallpaper-sync.lock" "/tmp/wallpaper-changer.lock" "/tmp/waybar-sync.lock")

# Funci√≥n de logging
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Funci√≥n de limpieza
cleanup() {
    rm -f "$LOCK_FILE"
    log "Watchdog terminado"
    exit 0
}

# Verificar si ya est√° corriendo
if [[ -f "$LOCK_FILE" ]] && kill -0 $(cat "$LOCK_FILE") 2>/dev/null; then
    echo "Waybar watchdog ya est√° corriendo"
    exit 1
fi

# Crear archivo de bloqueo
echo $$ > "$LOCK_FILE"
trap cleanup EXIT INT TERM

log "=== Iniciando Waybar Watchdog ==="

# Funci√≥n para verificar si alg√∫n script de wallpaper est√° corriendo
check_wallpaper_scripts() {
    for lock_file in "${WALLPAPER_LOCK_FILES[@]}"; do
        if [[ -f "$lock_file" ]]; then
            local pid=$(cat "$lock_file" 2>/dev/null)
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                return 0  # Script de wallpaper est√° corriendo
            fi
        fi
    done
    return 1  # No hay scripts de wallpaper corriendo
}

while true; do
    # Verificar si alg√∫n script de wallpaper est√° corriendo
    if check_wallpaper_scripts; then
        log "‚ÑπÔ∏è Script de wallpaper en progreso, pausando watchdog..."
        sleep $CHECK_INTERVAL
        continue
    fi
    
    # Verificar si waybar est√° corriendo
    if ! pgrep -x waybar > /dev/null; then
        ((CONSECUTIVE_FAILURES++))
        log "‚ö†Ô∏è Waybar no est√° corriendo (fallo $CONSECUTIVE_FAILURES/$MAX_FAILURES_BEFORE_RESTART)"
        
        # Solo reiniciar despu√©s de m√∫ltiples fallos para evitar reiniciar demasiado
        if [[ $CONSECUTIVE_FAILURES -ge $MAX_FAILURES_BEFORE_RESTART ]]; then
            log "üîÑ Iniciando reinicio despu√©s de $CONSECUTIVE_FAILURES fallos consecutivos..."
            
            # Usar el script de reinicio √∫nico optimizado
            if [[ -x ~/.local/bin/waybar-single-restart ]]; then
                ~/.local/bin/waybar-single-restart > /dev/null 2>&1
            else
                # Fallback simple
                nohup waybar > /dev/null 2>&1 &
            fi
            
            sleep 4
            if pgrep -x waybar > /dev/null; then
                log "‚úÖ Waybar reiniciado exitosamente despu√©s de $CONSECUTIVE_FAILURES fallos"
                notify-send "üîÑ Waybar Watchdog" "Waybar reiniciado tras $CONSECUTIVE_FAILURES fallos" -t 3000 2>/dev/null || true
                CONSECUTIVE_FAILURES=0
            else
                log "‚ùå Error: No se pudo reiniciar Waybar"
                # Solo despu√©s de m√∫ltiples intentos fallidos, usar el script robusto
                if [[ $CONSECUTIVE_FAILURES -ge $((MAX_FAILURES_BEFORE_RESTART * 2)) ]]; then
                    ~/.local/bin/restart-waybar-robust > /dev/null 2>&1
                    if pgrep -x waybar > /dev/null; then
                        log "‚úÖ Waybar reiniciado con script robusto"
                        CONSECUTIVE_FAILURES=0
                    else
                        log "‚ùå CR√çTICO: No se pudo reiniciar Waybar con ning√∫n m√©todo"
                        notify-send "‚ùå Error Waybar" "Watchdog no pudo reiniciar Waybar" -u critical -t 5000 2>/dev/null || true
                    fi
                fi
            fi
        fi
    else
        # Waybar est√° corriendo, resetear contador
        if [[ $CONSECUTIVE_FAILURES -gt 0 ]]; then
            log "‚úÖ Waybar volvi√≥ a funcionar, reseteando contador de fallos"
            CONSECUTIVE_FAILURES=0
        fi
    fi
    
    sleep $CHECK_INTERVAL
done
