#!/bin/bash

# Wallpaper changer mejorado CON sincronizaciÃ³n automÃ¡tica de waybar-pywal
# Combina el selector de wallpapers con la sincronizaciÃ³n completa de Waybar
# Ejecutado por: Super + Shift + W

set -euo pipefail

WALLPAPER_DIR="$HOME/Pictures/Wallpapers"
CACHE_DIR="$HOME/.cache/wallpaper-previews"
TEMP_FILE="/tmp/rofi_wallpaper_$$"
LOG_FILE="$HOME/.cache/wallpaper-changer-with-waybar.log"
LOCK_FILE="/tmp/wallpaper-waybar-change.lock"

# Crear directorios necesarios
mkdir -p "$CACHE_DIR"
mkdir -p "$(dirname "$LOG_FILE")"

# FunciÃ³n de logging
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
    echo "$1" >&2
}

# FunciÃ³n para ocultar Waybar de forma temporal y segura
hide_waybar() {
    local waybar_pids=$(pgrep -x waybar)
    if [[ -n "$waybar_pids" ]]; then
        # Usar SIGUSR1 para toggle (ocultar/mostrar)
        kill -USR1 $waybar_pids 2>/dev/null && log "ğŸ“± Waybar ocultado temporalmente" || true
    fi
}

# FunciÃ³n para mostrar Waybar de forma segura
show_waybar() {
    local waybar_pids=$(pgrep -x waybar)
    if [[ -n "$waybar_pids" ]]; then
        # Verificar si waybar estÃ¡ oculto y mostrarlo
        kill -USR1 $waybar_pids 2>/dev/null && log "ğŸ“± Waybar mostrado nuevamente" || true
        # Dar un momento para que se procese la seÃ±al
        sleep 0.5
    else
        log "ğŸš€ Waybar no estaba corriendo, iniciÃ¡ndolo..."
        waybar > /dev/null 2>&1 &
        sleep 1
        # Verificar que se iniciÃ³ correctamente
        if pgrep -x waybar > /dev/null; then
            log "âœ… Waybar iniciado correctamente"
        else
            log "âŒ ERROR: No se pudo iniciar waybar en show_waybar"
        fi
    fi
}

# FunciÃ³n para recargar Waybar CSS
reload_waybar_css() {
    pkill -SIGUSR1 waybar 2>/dev/null || true
}

# FunciÃ³n de limpieza (SIN REINICIAR WAYBAR)
cleanup() {
    local exit_code=$?
    # NO restaurar Waybar al salir para evitar mÃºltiples reinicios
    # show_waybar
    rm -f "$TEMP_FILE"* "$LOCK_FILE" 2>/dev/null || true
    if [[ $exit_code -ne 0 ]]; then
        log "ERROR: Script terminÃ³ con cÃ³digo $exit_code"
    fi
}

trap cleanup EXIT INT TERM

# Verificar si ya hay un cambio en progreso
if [[ -f "$LOCK_FILE" ]]; then
    lock_pid=$(cat "$LOCK_FILE" 2>/dev/null)
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
        log "â³ Cambio de wallpaper+waybar ya en progreso (PID: $lock_pid)"
        exit 0
    else
        rm -f "$LOCK_FILE"
    fi
fi

# Crear archivo de bloqueo
echo $$ > "$LOCK_FILE"

log "=== Iniciando selector de wallpapers con sincronizaciÃ³n waybar-pywal ==="

# FunciÃ³n para aplicar wallpaper CON sincronizaciÃ³n completa de waybar
apply_wallpaper_with_waybar_sync() {
    local wallpaper_file="$1"
    
    log "ğŸ–¼ï¸ Aplicando wallpaper: $wallpaper_file"
    
    # Detener temporalmente el waybar-watchdog para evitar conflictos
    local watchdog_pid=$(pgrep -f "waybar-watchdog" 2>/dev/null || true)
    if [[ -n "$watchdog_pid" ]]; then
        log "â¸ï¸ Pausando waybar-watchdog temporalmente..."
        kill -STOP "$watchdog_pid" 2>/dev/null || true
    fi
    
    # Aplicar wallpaper con swww
    if swww img "$wallpaper_file" --transition-type grow --transition-pos "0.9,0.1" --transition-duration 1.5; then
        log "âœ… Wallpaper aplicado con swww"
    else
        log "âŒ Error al aplicar wallpaper con swww"
        [[ -n "$watchdog_pid" ]] && kill -CONT "$watchdog_pid" 2>/dev/null || true
        return 1
    fi
    
    # Guardar wallpaper actual
    echo "$wallpaper_file" > "$HOME/.cache/current-wallpaper"
    
    # Si pywal estÃ¡ disponible, aplicar colores Y sincronizar waybar
    if command -v wal >/dev/null 2>&1; then
        log "ğŸ¨ Aplicando colores con pywal..."
        notify-send "ğŸŒˆ Generando colores y sincronizando Waybar..." "Aplicando tema completo" -t 3000 2>/dev/null || true
        
        # Aplicar pywal
        if wal -i "$wallpaper_file" -n -q; then
            log "âœ… Pywal aplicado exitosamente"
            
            # Esperar a que pywal genere archivos
            sleep 1.5
            
            # Recargar Hyprland
            hyprctl reload >/dev/null 2>&1 || log "WARNING: No se pudo recargar Hyprland"
            
            # SINCRONIZACIÃ“N ULTRA-OPTIMIZADA DE WAYBAR (CERO REINICIOS SI ES POSIBLE)
            log "ğŸ¨ Sincronizando Waybar con colores pywal (SIN REINICIOS)..."
            if [[ -x "$HOME/.local/bin/waybar-pywal-sync" ]]; then
                # Usar el script sÃºper optimizado que evita reinicios
                "$HOME/.local/bin/waybar-pywal-sync"
                log "âœ… Waybar sincronizado exitosamente (optimizado - cero reinicios)"
            else
                # Fallback: recarga suave de CSS sin reiniciar proceso
                log "âš ï¸ Script optimizado no encontrado, aplicando recarga suave..."
                waybar_pids=$(pgrep -x waybar)
                if [[ -n "$waybar_pids" ]]; then
                    # SOLO recarga de CSS, sin reiniciar proceso
                    log "ğŸ¨ Aplicando recarga de CSS solamente..."
                    if kill -USR2 $waybar_pids 2>/dev/null; then
                        log "âœ… CSS recargado sin reiniciar waybar"
                        sleep 1
                    else
                        # Si USR2 falla, intentar HUP (recarga completa sin reiniciar)
                        log "ğŸ”„ Intentando recarga completa sin reiniciar..."
                        if kill -HUP $waybar_pids 2>/dev/null; then
                            log "âœ… Waybar recargado completamente sin reiniciar proceso"
                            sleep 1
                        else
                            # SOLO si todo falla, reinicio Ãºnico
                            log "âš ï¸ Recarga fallida, reiniciando waybar (1 vez Ãºnicamente)..."
                            kill -TERM $waybar_pids 2>/dev/null
                            sleep 1
                            waybar > /dev/null 2>&1 &
                        fi
                    fi
                else
                    # Si waybar no estÃ¡ corriendo, solo iniciarlo
                    log "ğŸš€ Waybar no estaba corriendo, iniciÃ¡ndolo..."
                    waybar > /dev/null 2>&1 &
                fi
                log "âœ… Waybar sincronizado (mÃ­nimos reinicios)"
            fi
            
            # SINCRONIZACIÃ“N DUNST CON WAYBAR/PYWAL (MEJORADO CON COLORES DINÃMICOS)
            log "ğŸ”” Sincronizando dunst con colores de Waybar/pywal..."
            
            # MÃ©todo 1: Script optimizado de sincronizaciÃ³n waybar-dunst
            if [[ -x "$HOME/.local/bin/sync-dunst-waybar-colors" ]]; then
                "$HOME/.local/bin/sync-dunst-waybar-colors" &
                local dunst_sync_pid=$!
                if timeout 8 wait $dunst_sync_pid 2>/dev/null; then
                    log "âœ… Dunst sincronizado con Waybar usando script optimizado"
                else
                    log "âš ï¸ SincronizaciÃ³n dunst continuando en segundo plano..."
                    disown $dunst_sync_pid 2>/dev/null || true
                fi
            # MÃ©todo 2: Template de pywal (automÃ¡tico)
            elif [[ -f "$HOME/.cache/wal/dunstrc" ]]; then
                log "ğŸ“‹ Usando template de pywal para dunst..."
                cp "$HOME/.cache/wal/dunstrc" "$HOME/.config/dunst/dunstrc" 2>/dev/null || true
                
                # Reiniciar dunst
                pkill dunst 2>/dev/null || true
                sleep 1
                dunst > /dev/null 2>&1 &
                log "âœ… Dunst sincronizado con template de pywal"
            # MÃ©todo 3: Fallback directo
            else
                log "ğŸ”” Aplicando sincronizaciÃ³n directa de dunst..."
                
                # Reiniciar dunst con configuraciÃ³n actual
                pkill dunst 2>/dev/null || true
                sleep 1
                dunst > /dev/null 2>&1 &
                log "âœ… Dunst recargado con configuraciÃ³n actual"
            fi
            
            
            # SINCRONIZACIÃ“N GTK CON PYWAL (PywalGTK Theme) - NO BLOQUEAR nm-applet sync
            log "ğŸ¨ Sincronizando GTK con colores pywal..."
            if [[ -x "$HOME/.config/hypr/sync-gtk-pywal.sh" ]]; then
                # Ejecutar sincronizaciÃ³n GTK en segundo plano COMPLETAMENTE
                "$HOME/.config/hypr/sync-gtk-pywal.sh" &
                local gtk_pid=$!
                
                # Solo esperar 3 segundos para GTK, luego continuar con nm-applet
                if timeout 3 wait $gtk_pid 2>/dev/null; then
                    log "âœ… GTK sincronizado con pywal exitosamente"
                else
                    log "âš ï¸ GTK sync continuando en segundo plano..."
                    disown $gtk_pid 2>/dev/null || true
                    
                    # Aplicar configuraciones bÃ¡sicas mientras tanto
                    if command -v gsettings &>/dev/null; then
                        gsettings set org.gnome.desktop.interface gtk-theme "PywalGTK" 2>/dev/null || true
                        log "ğŸ”§ ConfiguraciÃ³n bÃ¡sica GTK aplicada"
                    fi
                fi
            else
                log "âš ï¸ Script sync-gtk-pywal.sh no encontrado, omitiendo sincronizaciÃ³n GTK"
            fi
            
            # SINCRONIZAR NM-APPLET CON COLORES DE WAYBAR (VERSIÃ“N MEJORADA)
            log "ğŸ“¶ Sincronizando nm-applet con colores de waybar (versiÃ³n mejorada)..."
            if [[ -x "$HOME/.local/bin/nm-applet-auto-sync" ]]; then
                "$HOME/.local/bin/nm-applet-auto-sync" &
                local nm_sync_pid=$!
                
                # Esperar mÃ¡ximo 10 segundos para la sincronizaciÃ³n de nm-applet
                if timeout 10 wait $nm_sync_pid 2>/dev/null; then
                    log "âœ… nm-applet sincronizado con colores de waybar exitosamente (versiÃ³n mejorada)"
                else
                    log "âš ï¸ nm-applet sync tomÃ³ mÃ¡s tiempo del esperado (continuando en segundo plano)"
                    disown $nm_sync_pid 2>/dev/null || true
                fi
            elif [[ -x "$HOME/.local/bin/nm-applet-waybar-sync" ]]; then
                # Fallback al script anterior
                "$HOME/.local/bin/nm-applet-waybar-sync" &
                local nm_sync_pid=$!
                
                if timeout 10 wait $nm_sync_pid 2>/dev/null; then
                    log "âœ… nm-applet sincronizado con script anterior"
                else
                    log "âš ï¸ nm-applet sync (fallback) continuando en segundo plano"
                    disown $nm_sync_pid 2>/dev/null || true
                fi
            else
                # Fallback mejorado: usar script automÃ¡tico de pywal
                log "âš ï¸ Script nm-applet-waybar-sync no encontrado, usando fallback mejorado..."
                if [[ -x "$HOME/.config/wal/done.d/nm-applet-sync.sh" ]]; then
                    "$HOME/.config/wal/done.d/nm-applet-sync.sh" &
                    disown
                    log "âœ… nm-applet sincronizaciÃ³n iniciada con script de pywal"
                elif [[ -x "$HOME/.local/bin/full-system-color-sync" ]]; then
                    # Usar sincronizaciÃ³n completa del sistema como fallback
                    "$HOME/.local/bin/full-system-color-sync" &
                    disown
                    log "âœ… SincronizaciÃ³n completa del sistema iniciada"
                else
                    # Ãšltimo recurso: aplicar tema sin reiniciar
                    log "ğŸ¨ Aplicando tema a nm-applet sin reiniciar..."
                    # Solo aplicar configuraciones GTK sin matar el proceso
                    export GTK_THEME="PywalGTK-Auto"
                    export GDK_BACKEND="wayland,x11"
                    
                    # Aplicar configuraciones GTK usando gsettings
                    if command -v gsettings &> /dev/null; then
                        gsettings set org.gnome.desktop.interface gtk-theme "PywalGTK-Auto" 2>/dev/null || true
                        gsettings set org.gnome.desktop.interface color-scheme "prefer-dark" 2>/dev/null || true
                    fi
                    
                    # Enviar seÃ±ales D-Bus para actualizar tema sin reiniciar
                    if command -v dbus-send &> /dev/null; then
                        dbus-send --type=signal /org/gtk/Settings org.gtk.Settings.SettingChanged string:"gtk-theme-name" string:"PywalGTK-Auto" 2>/dev/null || true
                        dbus-send --type=signal /org/gtk/Settings org.gtk.Settings.StyleUpdated 2>/dev/null || true
                    fi
                    
                    log "âœ… Tema aplicado a nm-applet sin reiniciar"
                fi
            fi
            # CONFIGURAR TEMA ARC WIDGET + TELA CIRCLE BLACK ICONS
            log "ğŸ›ï¸ Configurando tema Arc widget + Tela circle black icons..."
            if command -v gsettings &> /dev/null; then
                # Aplicar tema Arc-Dark (widgets)
                if gsettings set org.gnome.desktop.interface gtk-theme "Arc-Dark" 2>/dev/null; then
                    log "âœ… Tema Arc-Dark aplicado exitosamente"
                    notify-send "ğŸ¨ Tema Arc Aplicado" "Widgets configurados con Arc-Dark" -t 2000 2>/dev/null || true
                else
                    # Fallback a Arc
                    log "âš ï¸ Intentando con Arc..."
                    if gsettings set org.gnome.desktop.interface gtk-theme "Arc" 2>/dev/null; then
                        log "âœ… Tema Arc aplicado como fallback"
                        notify-send "ğŸ¨ Tema Arc Aplicado" "Widgets configurados con Arc" -t 2000 2>/dev/null || true
                    else
                        log "âš ï¸ gsettings disponible pero no se pudo aplicar tema Arc"
                    fi
                fi
            else
                log "âš ï¸ gsettings no disponible, no se puede aplicar tema Arc"
            fi
            
            # Configuraciones adicionales de GTK: Tela circle black + cursor
            if command -v gsettings &> /dev/null; then
                # Aplicar tema de iconos Tela circle black
                if gsettings set org.gnome.desktop.interface icon-theme "Tela-circle-black-dark" 2>/dev/null; then
                    log "âœ… Iconos Tela-circle-black-dark aplicados"
                    notify-send "ğŸ¨ Iconos Tela Aplicados" "Tela-circle-black-dark configurado" -t 2000 2>/dev/null || true
                else
                    # Fallback a Tela-circle-black
                    log "âš ï¸ Intentando con Tela-circle-black..."
                    if gsettings set org.gnome.desktop.interface icon-theme "Tela-circle-black" 2>/dev/null; then
                        log "âœ… Iconos Tela-circle-black aplicados como fallback"
                        notify-send "ğŸ¨ Iconos Tela Aplicados" "Tela-circle-black configurado" -t 2000 2>/dev/null || true
                    else
                        log "âš ï¸ No se pudo aplicar tema de iconos Tela circle black"
                    fi
                fi
                
                # Configurar cursor
                gsettings set org.gnome.desktop.interface cursor-theme "Bibata-Modern-Ice" 2>/dev/null || true
                log "ğŸ”§ Configuraciones Arc + Tela circle black aplicadas"
            fi
            
            # Reactivar waybar-watchdog
            if [[ -n "$watchdog_pid" ]]; then
                kill -CONT "$watchdog_pid" 2>/dev/null || true
                log "â–¶ï¸ Waybar-watchdog reactivado"
            fi
            
            notify-send "ğŸ¨ Tema Completo Aplicado" "Wallpaper + Pywal + Waybar + Dunst + GTK + nm-applet sincronizados" -t 4500 2>/dev/null || true
            
        else
            log "âŒ Error: Pywal fallÃ³"
            notify-send "âš ï¸ Error Pywal" "Se aplicÃ³ el wallpaper pero fallÃ³ la generaciÃ³n de colores" -t 3000 2>/dev/null || true
        fi
    else
        log "â„¹ï¸ Pywal no disponible, solo wallpaper aplicado"
        notify-send "âœ… Wallpaper Aplicado" "$(basename "$wallpaper_file")" -t 2000 2>/dev/null || true
    fi
}

# Verificar directorio de wallpapers
if [[ ! -d "$WALLPAPER_DIR" ]]; then
    log "ERROR: Directorio $WALLPAPER_DIR no encontrado"
    notify-send "âŒ Error" "Directorio de wallpapers no encontrado" -u critical
    exit 1
fi

# Verificar swww
if ! command -v swww &>/dev/null; then
    log "ERROR: swww no estÃ¡ instalado"
    notify-send "âŒ Error" "swww no estÃ¡ instalado" -u critical
    exit 1
fi

# Verificar e iniciar swww-daemon si es necesario
if ! pgrep -x "swww-daemon" >/dev/null; then
    log "ğŸš€ Iniciando swww-daemon..."
    notify-send "ğŸ”„ Iniciando swww..." "Preparando sistema de wallpapers"
    swww-daemon --format xrgb &
    sleep 3
fi

# Buscar imÃ¡genes
log "ğŸ” Buscando imÃ¡genes en $WALLPAPER_DIR"
cd "$WALLPAPER_DIR" || { log "ERROR: No se pudo acceder a $WALLPAPER_DIR"; exit 1; }

mapfile -t images < <(find . -maxdepth 1 -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.gif" -o -iname "*.webp" -o -iname "*.bmp" \) | sed 's|^./||' | sort)

if [[ ${#images[@]} -eq 0 ]]; then
    log "ERROR: No se encontraron imÃ¡genes"
    notify-send "âŒ Error" "No se encontraron imÃ¡genes en el directorio" -u critical
    exit 1
fi

log "ğŸ“ Encontradas ${#images[@]} imÃ¡genes"

# Crear archivo temporal para rofi
> "$TEMP_FILE"

# Procesar cada imagen para crear previews
for img in "${images[@]}"; do
    [[ ! -f "$img" ]] && continue
    
    clean_name="${img%.*}"
    preview_file="$CACHE_DIR/preview_${clean_name}.png"
    
    # Crear preview si no existe
    if [[ ! -f "$preview_file" ]]; then
        if [[ "$img" == *.gif ]]; then
            convert "$img[0]" -resize "200x150^" -gravity center -extent "200x150" "$preview_file" 2>/dev/null || continue
        else
            convert "$img" -resize "200x150^" -gravity center -extent "200x150" "$preview_file" 2>/dev/null || continue
        fi
    fi
    
    # Agregar entrada a rofi
    if [[ -f "$preview_file" ]]; then
        echo -e "$clean_name\\0icon\\x1f$preview_file" >> "$TEMP_FILE"
    else
        echo "$clean_name" >> "$TEMP_FILE"
    fi
done

# Verificar que tenemos entradas
if [[ ! -s "$TEMP_FILE" ]]; then
    log "ERROR: No se pudieron procesar las imÃ¡genes"
    notify-send "âŒ Error" "No se pudieron procesar las imÃ¡genes" -u critical
    exit 1
fi

log "ğŸ­ Mostrando selector de wallpapers con sincronizaciÃ³n waybar..."

# Ocultar Waybar antes de mostrar Rofi
hide_waybar
log "ğŸ“± Waybar ocultado para mostrar selector"

# Ejecutar rofi con tema apropiado
selected=$(rofi -dmenu -i \
    -p "ğŸ–¼ï¸ Wallpaper + Waybar Sync" \
    -show-icons \
    -theme "$HOME/HyprNova/.config/rofi/themes/wallpaper-select.rasi" \
    < "$TEMP_FILE")

# Si no se selecciÃ³nÃ³ nada, mostrar waybar y salir
if [[ -z "$selected" ]]; then
    log "â„¹ï¸ No se selecciÃ³nÃ³ ningÃºn wallpaper"
    show_waybar
    exit 0
fi

log "âœ… Seleccionado: $selected"

# Buscar el archivo correspondiente
selected_file=""
for img in "${images[@]}"; do
    if [[ "${img%.*}" == "$selected" ]]; then
        selected_file="$WALLPAPER_DIR/$img"
        break
    fi
done

# Verificar archivo seleccionado
if [[ -z "$selected_file" ]] || [[ ! -f "$selected_file" ]]; then
    log "ERROR: Archivo no encontrado: $selected"
    notify-send "âŒ Error" "Archivo no encontrado" -u critical
    exit 1
fi

# Aplicar wallpaper CON sincronizaciÃ³n completa de waybar
apply_wallpaper_with_waybar_sync "$selected_file"

# NO hacer verificaciÃ³n final para evitar reinicios adicionales
log "âœ… Proceso completado - Waybar deberÃ­a estar funcionando correctamente"

log "ğŸ‰ Script completado exitosamente - Wallpaper y Waybar sincronizados"
exit 0
