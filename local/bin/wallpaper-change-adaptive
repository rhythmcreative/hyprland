#!/bin/bash

# Script adaptativo para cambiar wallpaper que se ajusta al monitor activo
# Basado en wallpaper-change-fixed con detecci√≥n de monitor
# Ejecutado por: Super + Shift + W en Hyprland

set -euo pipefail

WALLPAPER_DIR="$HOME/Pictures/Wallpapers"
CACHE_DIR="$HOME/.cache/wallpaper-previews"
TEMP_FILE="/tmp/rofi_wallpaper_adaptive_$$"
LOG_FILE="$HOME/.cache/wallpaper-change-adaptive.log"
LOCK_FILE="/tmp/wallpaper-change-adaptive.lock"

# Funci√≥n de logging con timestamp
log() {
    local message="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    echo "$message" >> "$LOG_FILE"
}

# Funci√≥n de notificaci√≥n
notify() {
    notify-send "üé® Wallpaper Change" "$1" -t 3000 2>/dev/null || true
}

# Verificar si ya est√° ejecut√°ndose
if [[ -f "$LOCK_FILE" ]]; then
    lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
        log "‚è≥ Cambio de wallpaper ya en progreso (PID: $lock_pid)"
        exit 0
    fi
fi

# Crear lock
echo $$ > "$LOCK_FILE"

# Funci√≥n para detectar el monitor activo basado en posici√≥n del cursor
get_active_monitor() {
    # PRIORIDAD 1: Detectar por posici√≥n del cursor
    local cursor_info=$(hyprctl cursorpos 2>/dev/null)
    if [ -n "$cursor_info" ]; then
        local cursor_x=$(echo "$cursor_info" | cut -d',' -f1 | tr -d ' ')
        local cursor_y=$(echo "$cursor_info" | cut -d',' -f2 | tr -d ' ')
        
        log "Cursor en coordenadas: ($cursor_x, $cursor_y)"
        
        # Obtener informaci√≥n de todos los monitores
        local monitors=$(hyprctl monitors -j 2>/dev/null)
        
        if [ -n "$monitors" ]; then
            local cursor_monitor=$(echo "$monitors" | jq -r --arg cx "$cursor_x" --arg cy "$cursor_y" '
                .[] | select(
                    ($cx | tonumber) >= .x and 
                    ($cx | tonumber) < (.x + .width) and 
                    ($cy | tonumber) >= .y and 
                    ($cy | tonumber) < (.y + .height)
                ) | .name' 2>/dev/null | head -n1)
            
            if [ -n "$cursor_monitor" ] && [ "$cursor_monitor" != "null" ]; then
                log "Monitor detectado por cursor: $cursor_monitor"
                echo "$cursor_monitor"
                return
            fi
        fi
    fi
    
    # Fallback: usar el monitor principal/focused
    local focused_monitor=$(hyprctl monitors -j 2>/dev/null | jq -r '.[] | select(.focused == true) | .name' 2>/dev/null)
    if [ -n "$focused_monitor" ] && [ "$focused_monitor" != "null" ]; then
        log "Monitor detectado como focused: $focused_monitor"
        echo "$focused_monitor"
        return
    fi
    
    # √öltimo recurso
    log "No se pudo detectar monitor, usando eDP-1 por defecto"
    echo "eDP-1"
}

# NUEVA FUNCI√ìN: Sincronizaci√≥n optimizada de rofi con pywal
sync_rofi_with_pywal() {
    log "üé® Iniciando sincronizaci√≥n optimizada de rofi con pywal..."
    
    # Verificar que pywal gener√≥ el archivo colors-rofi.rasi
    if [[ -f "$HOME/.cache/wal/colors-rofi.rasi" ]]; then
        log "‚úÖ Archivo colors-rofi.rasi generado por pywal"
        
        # Copiar archivo de colores al directorio de configuraci√≥n de rofi
        mkdir -p "$HOME/.config/rofi"
        cp "$HOME/.cache/wal/colors-rofi.rasi" "$HOME/.config/rofi/colors-pywal.rasi"
        log "üìã Colores de rofi copiados a ~/.config/rofi/colors-pywal.rasi"
        
        # Generar versiones optimizadas con colores pywal para temas existentes
        for theme_file in "$HOME/.config/rofi/style-3.rasi" "$HOME/.config/rofi/wallpaper-select.rasi"; do
            if [[ -f "$theme_file" ]]; then
                local theme_name=$(basename "$theme_file" .rasi)
                local pywal_theme="$HOME/.config/rofi/${theme_name}-pywal.rasi"
                
                log "üìã Creando versi√≥n pywal optimizada de tema: $theme_name"
                
                # Crear versi√≥n optimizada que use los colores de pywal
                create_optimized_pywal_theme "$theme_file" "$pywal_theme"
            fi
        done
        
        log "‚úÖ Todos los temas de rofi sincronizados con pywal"
        return 0
    else
        log "‚ö†Ô∏è colors-rofi.rasi no generado por pywal"
        return 1
    fi
}

# Funci√≥n para crear temas optimizados que respeten completamente pywal
create_optimized_pywal_theme() {
    local original_theme="$1"
    local pywal_theme="$2"
    local temp_file="$(mktemp)"
    
    log "üîß Creando tema optimizado: $(basename "$pywal_theme")"
    
    # Validar que el tema original existe
    if [[ ! -f "$original_theme" ]]; then
        log "‚ùå ERROR: Tema original no encontrado: $original_theme"
        return 1
    fi
    
    # Escribir importaci√≥n de colores pywal al principio
    echo '@import "colors-pywal.rasi"' > "$temp_file"
    echo '' >> "$temp_file"
    
    # Procesar el archivo original, eliminando COMPLETAMENTE colores hardcodeados
    local in_color_section=false
    local brace_count=0
    
    while IFS= read -r line; do
        # Detectar inicio de secci√≥n de colores
        if [[ "$line" =~ ^[[:space:]]*\*[[:space:]]*\{[[:space:]]*$ ]]; then
            echo "$line" >> "$temp_file"
            in_color_section=true
            brace_count=1
            echo "    /* Los colores se importan autom√°ticamente desde colors-pywal.rasi */" >> "$temp_file"
            continue
        fi
        
        # Contar llaves para saber cu√°ndo termina la secci√≥n
        if [[ "$in_color_section" == "true" ]]; then
            if [[ "$line" == *"{"* ]]; then
                ((brace_count++))
            fi
            if [[ "$line" == *"}"* ]]; then
                ((brace_count--))
                if [[ $brace_count -eq 0 ]]; then
                    in_color_section=false
                    echo "$line" >> "$temp_file"
                    continue
                fi
            fi
        fi
        
        # Si estamos en la secci√≥n de colores, omitir colores hardcodeados
        if [[ "$in_color_section" == "true" ]]; then
            if [[ "$line" =~ ^[[:space:]]*(bgcolor|background|background-alt|foreground|foreground-alt|selected|active|urgent|color[0-9]+)[[:space:]]*:[[:space:]]*#[0-9A-Fa-f]+ ]] || 
               [[ "$line" =~ ^[[:space:]]*(bgcolor|background|background-alt|foreground|foreground-alt|selected|active|urgent|color[0-9]+)[[:space:]]*:[[:space:]]*rgba\( ]]; then
                # Omitir completamente (no incluir ni como comentario)
                continue
            fi
        fi
        
        # Incluir todas las dem√°s l√≠neas
        echo "$line" >> "$temp_file"
    done < "$original_theme"
    
    # Verificar que el archivo se gener√≥ correctamente
    if [[ -s "$temp_file" ]]; then
        # Mover archivo temporal al destino final
        mv "$temp_file" "$pywal_theme"
        log "‚úÖ Tema optimizado creado: $(basename "$pywal_theme")"
        return 0
    else
        log "‚ùå ERROR: No se pudo generar el tema optimizado"
        rm -f "$temp_file"
        return 1
    fi
}

# Funci√≥n para validar la sincronizaci√≥n de pywal y reparar si es necesario
validate_and_repair_pywal_sync() {
    log "üîç Validando sincronizaci√≥n de pywal con rofi..."
    local repair_needed=false
    local validated=true
    
    # Verificar que pywal est√° disponible
    if ! command -v wal > /dev/null 2>&1; then
        log "‚ö†Ô∏è Pywal no est√° disponible - usando fallback"
        return 1
    fi
    
    # Verificar archivos base de pywal
    local required_files=(
        "$HOME/.cache/wal/colors-rofi.rasi"
        "$HOME/.cache/wal/colors.sh"
        "$HOME/.config/rofi/colors-pywal.rasi"
    )
    
    for file in "${required_files[@]}"; do
        if [[ ! -f "$file" ]]; then
            log "‚ö†Ô∏è Archivo faltante: $file"
            repair_needed=true
            validated=false
        fi
    done
    
    # Verificar temas sincronizados
    local theme_files=(
        "wallpaper-select-pywal.rasi"
        "style-3-pywal.rasi"
    )
    
    for theme in "${theme_files[@]}"; do
        local theme_path="$HOME/.config/rofi/$theme"
        if [[ ! -f "$theme_path" ]]; then
            log "‚ö†Ô∏è Tema pywal faltante: $theme"
            repair_needed=true
        elif ! grep -q '@import "colors-pywal.rasi"' "$theme_path"; then
            log "‚ö†Ô∏è Tema pywal sin importaci√≥n correcta: $theme"
            repair_needed=true
        fi
    done
    
    # Reparar sincronizaci√≥n si es necesario
    if [[ "$repair_needed" == "true" ]]; then
        log "üîß Reparando sincronizaci√≥n de rofi con pywal..."
        if sync_rofi_with_pywal; then
            log "‚úÖ Sincronizaci√≥n reparada exitosamente"
            validated=true
        else
            log "‚ùå No se pudo reparar la sincronizaci√≥n"
            validated=false
        fi
    fi
    
    if [[ "$validated" == "true" ]]; then
        log "‚úÖ Sincronizaci√≥n de pywal con rofi validada"
        return 0
    else
        log "‚ùå Validaci√≥n de sincronizaci√≥n fall√≥"
        return 1
    fi
}

# Funci√≥n de fallback robusto para rofi
fallback_rofi_setup() {
    log "üîÑ Configurando fallback robusto para rofi..."
    
    # Intentar usar tema pywal si existe
    if validate_and_repair_pywal_sync; then
        log "‚úÖ Usando configuraci√≥n pywal reparada"
        return 0
    fi
    
    # Fallback 1: Usar tema original
    if [[ -f "$HOME/.config/rofi/wallpaper-select.rasi" ]]; then
        log "‚ö†Ô∏è Usando tema original como fallback"
        return 0
    fi
    
    # Fallback 2: Crear tema b√°sico de emergencia
    log "üÜò Creando tema b√°sico de emergencia..."
    mkdir -p "$HOME/.config/rofi"
    
    cat > "$HOME/.config/rofi/emergency-theme.rasi" << 'EOF'
/* Tema de emergencia generado autom√°ticamente */
configuration {
    modi: "drun";
    show-icons: true;
    drun-display-format: "{name}";
    hover-select: true;
    font: "Sans 10";
}

* {
    background: rgba(0, 0, 0, 0.8);
    foreground: #ffffff;
    selected: #0080ff;
    background-alt: rgba(0, 0, 0, 0.6);
}

window {
    transparency: "real";
    location: center;
    anchor: center;
    fullscreen: true;
    width: 100%;
    height: 100%;
    background-color: @background;
}

mainbox {
    children: [ "listview" ];
    background-color: transparent;
    padding: 64px;
}

listview {
    columns: 4;
    lines: 4;
    cycle: true;
    dynamic: true;
    scrollbar: false;
    layout: vertical;
    reverse: false;
    fixed-height: true;
    fixed-columns: true;
    background-color: transparent;
    spacing: 0px;
}

element {
    cursor: pointer;
    border-radius: 15px;
    background-color: transparent;
    text-color: @foreground;
    orientation: vertical;
    spacing: 15px;
    margin: 8px;
    padding: 20px 15px;
}

element selected.normal {
    background-color: rgba(255, 255, 255, 0.1);
    text-color: @selected;
    border: 1px solid;
    border-color: @selected;
}

element-icon {
    size: 200px;
    background-color: transparent;
}

element-text {
    background-color: transparent;
    text-color: inherit;
    vertical-align: 0.5;
    horizontal-align: 0.5;
}
EOF
    
    if [[ -f "$HOME/.config/rofi/emergency-theme.rasi" ]]; then
        log "‚úÖ Tema de emergencia creado exitosamente"
        return 0
    else
        log "‚ùå No se pudo crear tema de emergencia"
        return 1
    fi
}

# NUEVA FUNCI√ìN: Sincronizaci√≥n autom√°tica con el wallpaper actual (para ser llamada desde otros scripts)
sync_with_current_wallpaper() {
    local current_wallpaper_file="$HOME/.cache/current-wallpaper"
    local force_sync="${1:-false}"
    
    log "üîÑ === INICIANDO SINCRONIZACI√ìN AUTOM√ÅTICA CON WALLPAPER ACTUAL ==="
    
    # Verificar si existe el archivo de wallpaper actual
    if [[ ! -f "$current_wallpaper_file" ]]; then
        log "‚ö†Ô∏è No se encontr√≥ archivo de wallpaper actual: $current_wallpaper_file"
        return 1
    fi
    
    # Leer el wallpaper actual
    local current_wallpaper=$(cat "$current_wallpaper_file" 2>/dev/null)
    if [[ -z "$current_wallpaper" ]] || [[ ! -f "$current_wallpaper" ]]; then
        log "‚ö†Ô∏è Wallpaper actual no v√°lido o no existe: $current_wallpaper"
        return 1
    fi
    
    log "üì∏ Wallpaper actual detectado: $current_wallpaper"
    
    # Verificar si pywal est√° disponible
    if ! command -v wal > /dev/null 2>&1; then
        log "‚ö†Ô∏è pywal no est√° disponible para sincronizaci√≥n"
        return 1
    fi
    
    # Verificar si los colores ya est√°n sincronizados (a menos que se fuerce)
    if [[ "$force_sync" != "true" ]] && [[ -f "$HOME/.cache/wal/colors-hyprland.conf" ]]; then
        local wal_wallpaper=$(grep '^\$wallpaper' "$HOME/.cache/wal/colors-hyprland.conf" | cut -d'=' -f2 | tr -d ' ')
        if [[ "$wal_wallpaper" == "$current_wallpaper" ]]; then
            log "‚úÖ Los colores ya est√°n sincronizados con el wallpaper actual"
            # A√∫n as√≠, recargar Hyprland para asegurar sincronizaci√≥n
            log "üîÑ Recargando configuraci√≥n de Hyprland para asegurar sincronizaci√≥n..."
            if timeout 10s hyprctl reload > /dev/null 2>&1; then
                log "‚úÖ Configuraci√≥n de Hyprland recargada exitosamente"
            else
                log "‚ùå WARNING: No se pudo recargar Hyprland o timeout alcanzado"
            fi
            return 0
        fi
    fi
    
    log "üé® Aplicando colores de pywal desde wallpaper actual..."
    
    # Aplicar pywal al wallpaper actual
    if wal -i "$current_wallpaper" -n -q; then
        log "‚úÖ Pywal aplicado exitosamente al wallpaper actual"
        
        # Esperar a que pywal genere todos los archivos
        sleep 0.5
        
        # Actualizar archivo de colores para Waybar
        log "üé® Actualizando colores de Waybar..."
        if [[ -f "$HOME/.cache/wal/colors-waybar.css" ]]; then
            cp "$HOME/.cache/wal/colors-waybar.css" "$HOME/.config/waybar/colors-pywal.css"
            log "‚úÖ Archivo colors-waybar.css copiado"
        elif [[ -f "$HOME/.cache/wal/colors.css" ]]; then
            # Si no hay colors-waybar.css, generar desde colors.css
            cat > "$HOME/.config/waybar/colors-pywal.css" <<EOF
/* Colores generados autom√°ticamente por pywal */
$(grep -E '^--color[0-9]+|^--background|^--foreground|^--cursor' "$HOME/.cache/wal/colors.css" | sed 's/--/@define-color /' | sed 's/: / /g' | sed 's/;//g')
EOF
            log "‚úÖ Archivo colors-pywal.css generado desde colors.css"
        else
            # Generar desde colors.sh si no hay CSS
            source "$HOME/.cache/wal/colors.sh"
            cat > "$HOME/.config/waybar/colors-pywal.css" <<EOF
/* Colores generados autom√°ticamente por pywal */
@define-color background $background;
@define-color foreground $foreground;
@define-color cursor $cursor;
@define-color color0 $color0;
@define-color color1 $color1;
@define-color color2 $color2;
@define-color color3 $color3;
@define-color color4 $color4;
@define-color color5 $color5;
@define-color color6 $color6;
@define-color color7 $color7;
@define-color color8 $color8;
@define-color color9 $color9;
@define-color color10 $color10;
@define-color color11 $color11;
@define-color color12 $color12;
@define-color color13 $color13;
@define-color color14 $color14;
@define-color color15 $color15;
EOF
            log "‚úÖ Archivo colors-pywal.css generado desde colors.sh"
        fi
        
        # Recargar Hyprland config (para obtener nuevos colores)
        log "üîÑ Recargando configuraci√≥n de Hyprland..."
        if timeout 10s hyprctl reload > /dev/null 2>&1; then
            log "‚úÖ Configuraci√≥n de Hyprland recargada exitosamente"
        else
            log "‚ùå WARNING: No se pudo recargar Hyprland o timeout alcanzado"
        fi
        
        # Sincronizar Mako con pywal
        log "üîî Sincronizando Mako con colores de pywal..."
        if [[ -x "$HOME/.local/bin/sync-mako-pywal" ]]; then
            "$HOME/.local/bin/sync-mako-pywal"
            log "‚úÖ Mako sincronizado con colores de pywal"
        else
            log "‚ö†Ô∏è Script sync-mako-pywal no encontrado o no ejecutable"
        fi
        
        # Sincronizar temas de rofi con pywal
        log "üé® Sincronizando temas de rofi con pywal..."
        
        # Verificar que pywal gener√≥ el archivo colors-rofi.rasi
        if [[ -f "$HOME/.cache/wal/colors-rofi.rasi" ]]; then
            log "‚úÖ Archivo colors-rofi.rasi generado por pywal"
            
            # Copiar archivo de colores al directorio de configuraci√≥n de rofi
            mkdir -p "$HOME/.config/rofi"
            cp "$HOME/.cache/wal/colors-rofi.rasi" "$HOME/.config/rofi/colors-pywal.rasi"
            log "üìã Colores de rofi copiados a ~/.config/rofi/colors-pywal.rasi"
            
            # Generar versiones con colores pywal para temas existentes
            for theme_file in "$HOME/.config/rofi/style-3.rasi" "$HOME/.config/rofi/wallpaper-select.rasi"; do
                if [[ -f "$theme_file" ]]; then
                    local theme_name=$(basename "$theme_file" .rasi)
                    local pywal_theme="$HOME/.config/rofi/${theme_name}-pywal.rasi"
                    
                    log "üìã Creando versi√≥n pywal de tema: $theme_name"
                    
                    # Crear copia del tema original
                    cp "$theme_file" "$pywal_theme"
                    
                    # A√±adir importaci√≥n de colores pywal al principio del archivo
                    if ! grep -q '@import "colors-pywal.rasi"' "$pywal_theme"; then
                        # Crear archivo temporal con la importaci√≥n
                        local temp_file="$(mktemp)"
                        echo '@import "colors-pywal.rasi"' > "$temp_file"
                        echo '' >> "$temp_file"
                        cat "$pywal_theme" >> "$temp_file"
                        mv "$temp_file" "$pywal_theme"
                        
                        log "‚úÖ Importaci√≥n de colores pywal a√±adida a $theme_name"
                    fi
                fi
            done
            
            log "‚úÖ Todos los temas de rofi sincronizados con pywal"
        else
            log "‚ö†Ô∏è colors-rofi.rasi no generado por pywal"
        fi
        
        log "üéâ Sincronizaci√≥n autom√°tica completada exitosamente"
        return 0
    else
        log "‚ùå Error: Pywal fall√≥ durante la sincronizaci√≥n autom√°tica"
        return 1
    fi
}

# Funci√≥n de cleanup
cleanup() {
    local exit_code=$?
    
    # Limpiar archivos temporales
    rm -f "$TEMP_FILE"* 2>/dev/null || true
    rm -f "$LOCK_FILE"
    
    # Restaurar Waybar si estaba corriendo
    if [[ "${ORIGINAL_WAYBAR_STATE:-}" == "running" ]]; then
        if ! pgrep -x waybar > /dev/null 2>&1; then
            log "üì± Cleanup: Restaurando Waybar..."
            ensure_waybar_running
        fi
    fi
    
    log "üßπ Cleanup completado (exit code: $exit_code)"
}
trap cleanup EXIT INT TERM

# NUEVO: Verificar si se llama con par√°metro "sync-only" para sincronizaci√≥n autom√°tica
if [[ "${1:-}" == "sync-only" ]]; then
    log "üîÑ === MODO SINCRONIZACI√ìN AUTOM√ÅTICA ACTIVADO ==="
    
    # No crear lock file para sincronizaci√≥n r√°pida
    rm -f "$LOCK_FILE" 2>/dev/null || true
    
    # Ejecutar sincronizaci√≥n autom√°tica
    if sync_with_current_wallpaper "${2:-false}"; then
        notify "üé® Colores sincronizados autom√°ticamente con el wallpaper actual"
        log "‚úÖ Sincronizaci√≥n autom√°tica completada exitosamente"
        exit 0
    else
        notify "‚ö†Ô∏è Error en la sincronizaci√≥n autom√°tica"
        log "‚ùå Error en la sincronizaci√≥n autom√°tica"
        exit 1
    fi
fi

# Detectar monitor activo
ACTIVE_MONITOR=$(get_active_monitor)
log "Monitor activo detectado: $ACTIVE_MONITOR"

# Configurar tema de Rofi seg√∫n el monitor con soporte para pywal
configure_rofi_theme() {
    local monitor="$1"
    local rofi_theme=""
    local rofi_config=""
    local theme_name="wallpaper-select"
    local pywal_theme="$HOME/.config/rofi/${theme_name}-pywal.rasi"
    local fallback_theme="$HOME/.config/rofi/${theme_name}.rasi"
    
    # Prioridad 1: Usar tema sincronizado con pywal si existe y pywal est√° activo
    if [[ -f "$pywal_theme" ]] && [[ -f "$HOME/.cache/wal/colors-rofi.rasi" ]] && command -v wal > /dev/null 2>&1; then
        rofi_theme="$pywal_theme"
        log "üé® Usando tema sincronizado con pywal: $theme_name-pywal.rasi"
    # Prioridad 2: Usar tema original como fallback
    elif [[ -f "$fallback_theme" ]]; then
        rofi_theme="$fallback_theme"
        log "‚ö†Ô∏è Usando tema original (pywal no disponible): $theme_name.rasi"
    else
        log "‚ùå ERROR: No se encontr√≥ ning√∫n tema de rofi disponible"
        rofi_theme=""
    fi
    
    # Configurar par√°metros espec√≠ficos del monitor
    case "$monitor" in
        "DP-6")
            if [[ -n "$rofi_theme" ]]; then
                rofi_config="-theme '$rofi_theme' -font 'Inter 12' -width 900 -lines 15"
                log "üì∫ Configuraci√≥n optimizada para DP-6 (2560x1440) con tema: $(basename "$rofi_theme")"
            else
                rofi_config="-font 'Inter 12' -width 900 -lines 15"
                log "üì∫ Configuraci√≥n b√°sica para DP-6 (sin tema espec√≠fico)"
            fi
            ;;
        "eDP-1")
            if [[ -n "$rofi_theme" ]]; then
                rofi_config="-theme '$rofi_theme' -font 'Inter 10' -width 700 -lines 12"
                log "üíª Configuraci√≥n optimizada para eDP-1 (1920x1080) con tema: $(basename "$rofi_theme")"
            else
                rofi_config="-font 'Inter 10' -width 700 -lines 12"
                log "üíª Configuraci√≥n b√°sica para eDP-1 (sin tema espec√≠fico)"
            fi
            ;;
        *)
            if [[ -n "$rofi_theme" ]]; then
                rofi_config="-theme '$rofi_theme' -font 'Inter 11' -width 800 -lines 13"
                log "üñ•Ô∏è Configuraci√≥n por defecto para monitor: $monitor con tema: $(basename "$rofi_theme")"
            else
                rofi_config="-font 'Inter 11' -width 800 -lines 13"
                log "üñ•Ô∏è Configuraci√≥n b√°sica para monitor: $monitor (sin tema espec√≠fico)"
            fi
            ;;
    esac
    
    echo "$rofi_config"
}

# Funci√≥n para ocultar Waybar
hide_waybar() {
    log "üì± Ocultando Waybar..."
    if pgrep -x waybar > /dev/null; then
        pkill -KILL waybar 2>/dev/null
        sleep 0.1
        log "‚úÖ Waybar detenido"
    fi
}

# Funci√≥n para mostrar Waybar
show_waybar() {
    log "üì± Mostrando Waybar..."
    if ! pgrep -x waybar > /dev/null; then
        nohup waybar > /dev/null 2>&1 &
        sleep 0.3
        if pgrep -x waybar > /dev/null; then
            log "‚úÖ Waybar iniciado"
        fi
    fi
}

# Funci√≥n robusta para asegurar que waybar est√© corriendo
ensure_waybar_running() {
    log "üîß Asegurando que waybar est√© corriendo..."
    if ! pgrep -x waybar > /dev/null 2>&1; then
        nohup waybar > /dev/null 2>&1 &
        sleep 0.5
        if pgrep -x waybar > /dev/null 2>&1; then
            log "‚úÖ Waybar iniciado exitosamente"
            return 0
        else
            log "‚ùå No se pudo iniciar waybar"
            return 1
        fi
    else
        log "‚úÖ Waybar ya est√° corriendo"
        return 0
    fi
}

# Determinar estado original de waybar
if pgrep -x waybar > /dev/null; then
    ORIGINAL_WAYBAR_STATE="running"
    log "üìù Estado inicial: Waybar est√° ejecut√°ndose"
else
    ORIGINAL_WAYBAR_STATE="stopped"
    log "üìù Estado inicial: Waybar no est√° ejecut√°ndose"
fi

log "üöÄ === INICIANDO CAMBIO DE WALLPAPER ADAPTATIVO ==="
log "üñ•Ô∏è Monitor activo: $ACTIVE_MONITOR"
notify "Iniciando selector de wallpapers adaptativo..."

# Verificar directorio de wallpapers
if [[ ! -d "$WALLPAPER_DIR" ]]; then
    log "ERROR: Directorio $WALLPAPER_DIR no encontrado"
    notify "‚ùå Error: Directorio de wallpapers no encontrado"
    exit 1
fi

# Verificar swww
if ! command -v swww &> /dev/null; then
    log "ERROR: swww no est√° instalado"
    notify "‚ùå Error: swww no est√° instalado"
    exit 1
fi

# Verificar e iniciar swww-daemon si es necesario
if ! pgrep -x "swww-daemon" > /dev/null; then
    log "üöÄ Iniciando swww-daemon..."
    swww-daemon --format xrgb &
fi

# Crear directorios necesarios
mkdir -p "$CACHE_DIR"

# Buscar im√°genes
log "üîç Buscando im√°genes en $WALLPAPER_DIR"
cd "$WALLPAPER_DIR" || { log "ERROR: No se pudo acceder a $WALLPAPER_DIR"; exit 1; }

mapfile -t images < <(find . -maxdepth 1 -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.gif" -o -iname "*.webp" -o -iname "*.bmp" \) | sed 's|^./||' | sort)

if [[ ${#images[@]} -eq 0 ]]; then
    log "ERROR: No se encontraron im√°genes"
    notify "‚ùå Error: No se encontraron im√°genes"
    exit 1
fi

log "üìÅ Encontradas ${#images[@]} im√°genes"

# Crear archivo temporal para rofi
> "$TEMP_FILE"

# Funci√≥n para obtener tama√±os de preview seg√∫n el monitor
get_preview_size() {
    local monitor="$1"
    
    case "$monitor" in
        "DP-6")
            # Monitor 2560x1440 - previews m√°s grandes
            echo "200x133"  # Proporci√≥n 3:2, m√°s grande para monitor grande
            ;;
        "eDP-1")
            # Monitor 1920x1080 - previews m√°s peque√±os
            echo "120x80"   # Proporci√≥n 3:2, m√°s peque√±o para laptop
            ;;
        *)
            # Fallback - tama√±o medio
            echo "150x100"
            ;;
    esac
}

# Funci√≥n para generar preview r√°pida adaptativa seg√∫n monitor
generate_preview() {
    local img="$1"
    local monitor="$2"
    local preview_size=$(get_preview_size "$monitor")
    local clean_name="${img%.*}"
    local safe_name="$(echo "$clean_name" | sed 's/[^a-zA-Z0-9._-]/_/g')"
    local preview_file="$CACHE_DIR/preview_${safe_name}_${monitor}.png"
    
    log "üñºÔ∏è Generando preview $preview_size para monitor $monitor: $img"
    
    # Cache espec√≠fico por monitor: verificar si existe para este monitor y tama√±o
    if [[ -f "$preview_file" ]]; then
        return 0  # Ya existe, usar cache
    fi
    
    # Usar magick en lugar de convert para ImageMagick v7
    local convert_cmd="magick"
    if ! command -v magick &> /dev/null; then
        convert_cmd="convert"
    fi
    
    # Generar preview con tama√±o espec√≠fico del monitor
    if [[ "$img" == *.gif ]]; then
        $convert_cmd "$img[0]" -resize "${preview_size}^" -gravity center -extent "$preview_size" -strip -quality 60 "$preview_file" 2>/dev/null || {
            local placeholder="$HOME/.cache/wal/gif-placeholder-${monitor}.png"
            if [[ ! -f "$placeholder" ]]; then
                # Crear placeholder espec√≠fico para el tama√±o del monitor
                local width=$(echo "$preview_size" | cut -d'x' -f1)
                local height=$(echo "$preview_size" | cut -d'x' -f2)
                local fontsize=$((width / 12))  # Ajustar fuente seg√∫n ancho
                $convert_cmd -size "$preview_size" xc:"#2e3440" -pointsize "$fontsize" -fill white -gravity center -annotate +0+0 "GIF" "$placeholder" 2>/dev/null || touch "$placeholder"
            fi
            [[ -f "$placeholder" ]] && cp "$placeholder" "$preview_file" 2>/dev/null
        }
    else
        $convert_cmd "$img" -resize "${preview_size}^" -gravity center -extent "$preview_size" -strip -quality 60 "$preview_file" 2>/dev/null
    fi
    
    return 0
}

# Procesar im√°genes para rofi
log "üöÄ Generando previews adaptativas para monitor $ACTIVE_MONITOR..."
for img in "${images[@]}"; do
    clean_name="${img%.*}"
    safe_name="$(echo "$clean_name" | sed 's/[^a-zA-Z0-9._-]/_/g')"
    preview_file="$CACHE_DIR/preview_${safe_name}_${ACTIVE_MONITOR}.png"
    
    generate_preview "$img" "$ACTIVE_MONITOR"
    
    # A√±adir a archivo rofi
    if [[ -f "$preview_file" ]]; then
        echo -e "$img\\0icon\\x1f$preview_file" >> "$TEMP_FILE"
    else
        echo "$img" >> "$TEMP_FILE"
    fi
done

# Verificar que tenemos entradas
if [[ ! -s "$TEMP_FILE" ]]; then
    log "ERROR: No se pudieron procesar las im√°genes"
    notify "‚ùå Error: No se pudieron procesar las im√°genes"
    exit 1
fi

log "üé≠ Mostrando selector de wallpapers adaptativo..."

# Configurar rofi seg√∫n el monitor
ROFI_CONFIG=$(configure_rofi_theme "$ACTIVE_MONITOR")
log "üé® Configuraci√≥n de Rofi: $ROFI_CONFIG"

# Funci√≥n para ejecutar rofi con manejo correcto de waybar y monitor espec√≠fico
execute_adaptive_rofi() {
    local temp_file="$1"
    local monitor="$2"
    local config="$3"
    local result=""
    local waybar_was_running=false
    
    # Verificar si waybar est√° ejecut√°ndose antes de iniciarlo
    if pgrep -x waybar > /dev/null; then
        waybar_was_running=true
        log "üìù Waybar estaba ejecut√°ndose antes de rofi"
    fi
    
    log "üì± Ocultando waybar antes de rofi..."
    hide_waybar
    
    # Crear archivo limpio para rofi
    local rofi_temp_file="${temp_file}_rofi_$$"
    cat "$temp_file" > "$rofi_temp_file" 2>/dev/null
    
    log "üöÄ Ejecutando rofi adaptativo en monitor: $monitor"
    
    # Ejecutar rofi con configuraci√≥n espec√≠fica del monitor
    result=$(eval "rofi -dmenu -i -p \"üñºÔ∏è Seleccionar Wallpaper\" -show-icons $config -monitor '$monitor'" < "$rofi_temp_file" 2>/dev/null || true)
    
    # Limpiar archivo temporal
    rm -f "$rofi_temp_file"
    
    # Solo restaurar Waybar si NO vamos a reiniciarlo despu√©s con pywal
    if [[ "$waybar_was_running" == "true" ]] && ! command -v wal > /dev/null 2>&1; then
        log "üì± Restaurando waybar despu√©s de rofi (sin pywal)..."
        show_waybar
    elif [[ "$waybar_was_running" == "true" ]]; then
        log "üì± No se restaura waybar ahora - se reiniciar√° despu√©s con pywal"
    fi
    
    echo "$result"
}

# Ejecutar rofi con configuraci√≥n adaptativa
selected=$(execute_adaptive_rofi "$TEMP_FILE" "$ACTIVE_MONITOR" "$ROFI_CONFIG")

# Si no se seleccion√≥ nada, salir
if [[ -z "$selected" ]]; then
    log "‚ÑπÔ∏è No se seleccion√≥ ning√∫n wallpaper"
    exit 0
fi

log "‚úÖ Seleccionado: $selected"

# Buscar el archivo correspondiente
selected_file=""
if [[ -f "$WALLPAPER_DIR/$selected" ]]; then
    selected_file="$WALLPAPER_DIR/$selected"
    log "üéØ Archivo encontrado: $selected_file"
else
    for img in "${images[@]}"; do
        if [[ "${img%.*}" == "$selected" ]]; then
            selected_file="$WALLPAPER_DIR/$img"
            log "üéØ Archivo encontrado por fallback: $selected_file"
            break
        fi
    done
fi

# Verificar archivo seleccionado
if [[ -z "$selected_file" ]] || [[ ! -f "$selected_file" ]]; then
    log "‚ùå ERROR: Archivo no encontrado: $selected"
    notify "‚ùå Error: Archivo no encontrado"
    exit 1
fi

log "üñºÔ∏è PASO 1: Aplicando wallpaper: $selected_file"

# Aplicar wallpaper con swww
if swww img "$selected_file" --transition-type grow --transition-pos "0.9,0.1" --transition-duration 1.5; then
    log "‚úÖ Wallpaper aplicado con swww"
    notify "üñºÔ∏è Wallpaper aplicado: $(basename "$selected_file")"
else
    log "‚ùå Error al aplicar wallpaper con swww"
    exit 1
fi

# Guardar wallpaper actual
echo "$selected_file" > "$HOME/.cache/current-wallpaper"

# Aplicar pywal SOLO si est√° disponible
if command -v wal > /dev/null 2>&1; then
    log "üé® PASO 2: Aplicando colores con pywal..."
    notify "üåà Generando colores con pywal..."
    
    if wal -i "$selected_file" -n -q; then
        log "‚úÖ Pywal aplicado exitosamente"
        
        # Esperar a que pywal genere todos los archivos
        sleep 0.5
        
        # NUEVO: Actualizar archivo de colores para Waybar
        log "üé® PASO 3: Actualizando colores de Waybar..."
        if [[ -f "$HOME/.cache/wal/colors-waybar.css" ]]; then
            cp "$HOME/.cache/wal/colors-waybar.css" "$HOME/.config/waybar/colors-pywal.css"
            log "‚úÖ Archivo colors-waybar.css copiado"
        elif [[ -f "$HOME/.cache/wal/colors.css" ]]; then
            # Si no hay colors-waybar.css, generar desde colors.css
            cat > "$HOME/.config/waybar/colors-pywal.css" <<EOF
/* Colores generados autom√°ticamente por pywal */
$(grep -E '^--color[0-9]+|^--background|^--foreground|^--cursor' "$HOME/.cache/wal/colors.css" | sed 's/--/@define-color /' | sed 's/: / /g' | sed 's/;//g')
EOF
            log "‚úÖ Archivo colors-pywal.css generado desde colors.css"
        else
            # Generar desde colors.sh si no hay CSS
            source "$HOME/.cache/wal/colors.sh"
            cat > "$HOME/.config/waybar/colors-pywal.css" <<EOF
/* Colores generados autom√°ticamente por pywal */
@define-color background $background;
@define-color foreground $foreground;
@define-color cursor $cursor;
@define-color color0 $color0;
@define-color color1 $color1;
@define-color color2 $color2;
@define-color color3 $color3;
@define-color color4 $color4;
@define-color color5 $color5;
@define-color color6 $color6;
@define-color color7 $color7;
@define-color color8 $color8;
@define-color color9 $color9;
@define-color color10 $color10;
@define-color color11 $color11;
@define-color color12 $color12;
@define-color color13 $color13;
@define-color color14 $color14;
@define-color color15 $color15;
EOF
            log "‚úÖ Archivo colors-pywal.css generado desde colors.sh"
        fi
        
        # Recargar Hyprland config (para obtener nuevos colores)
        log "üîÑ PASO 4: Recargando configuraci√≥n de Hyprland..."
        if timeout 10s hyprctl reload > /dev/null 2>&1; then
            log "‚úÖ Configuraci√≥n de Hyprland recargada exitosamente"
        else
            log "‚ùå WARNING: No se pudo recargar Hyprland o timeout alcanzado"
        fi
        
        # Reiniciar Waybar UNA SOLA VEZ con los nuevos colores
        log "üì± PASO 5: Reiniciando Waybar con nuevos colores..."
        
        # Verificar que el archivo de colores existe antes de reiniciar waybar
        if [[ -f "$HOME/.config/waybar/colors-pywal.css" ]]; then
            log "‚úÖ Archivo de colores de waybar confirmado"
        else
            log "‚ùå WARNING: Archivo de colores de waybar no encontrado"
        fi
        
        # Cerrar waybar existente de forma m√°s robusta
        waybar_count=$(pgrep -x waybar | wc -l)
        log "üîç Instancias de waybar detectadas: $waybar_count"
        
        if [[ $waybar_count -gt 0 ]]; then
            log "üõë Cerrando todas las instancias de waybar..."
            # M√©todo progresivo: TERM primero, luego KILL
            pkill -TERM waybar 2>/dev/null || true
            sleep 0.2
            pkill -KILL waybar 2>/dev/null || true
            sleep 0.1
        fi
        
        # Iniciar waybar inmediatamente
        log "üöÄ Iniciando nueva instancia de waybar con colores actualizados..."
        nohup waybar > /dev/null 2>&1 &
        waybar_pid=$!
        
        # Esperar un poco m√°s para que waybar cargue los colores
        sleep 1.0
        
        if pgrep -x waybar > /dev/null; then
            log "‚úÖ Waybar reiniciado exitosamente con nuevos colores (PID: $waybar_pid)"
            
            # Verificaci√≥n adicional de que waybar carg√≥ correctamente
            sleep 0.5
            if hyprctl workspaces | grep -q "workspace ID"; then
                log "‚úÖ M√≥dulo de workspaces funcionando correctamente"
            else
                log "‚ö†Ô∏è Advertencia: No se pudo verificar el estado de workspaces"
            fi
        else
            log "‚ùå Error: Waybar no se inici√≥ correctamente"
            notify "‚ö†Ô∏è Error: Waybar no se inici√≥ despu√©s de aplicar colores"
        fi
        
        # Configurar temas GTK
        log "üé® PASO 6: Configurando temas GTK..."
        gsettings set org.gnome.desktop.interface gtk-theme "PywalSync-Mono" 2>/dev/null || true
        gsettings set org.gnome.desktop.interface icon-theme "Tela-circle-black-dark" 2>/dev/null || true
        export GTK_THEME="PywalSync-Mono"
        log "‚úÖ Temas GTK configurados a PywalSync-Mono"
        
        # Reiniciar nm-applet
        log "üåê PASO 7: Reiniciando nm-applet..."
        if pgrep -x nm-applet > /dev/null; then
            pkill -9 nm-applet 2>/dev/null || true
            sleep 0.2
        fi
        nm-applet --indicator > /dev/null 2>&1 &
        sleep 0.2
        if pgrep -x nm-applet > /dev/null; then
            log "‚úÖ nm-applet reiniciado exitosamente"
        fi
        
        # NUEVO: Sincronizaci√≥n de Mako con pywal
        log "üîî PASO 7.5: Sincronizando Mako con colores de pywal..."
        if [[ -x "$HOME/.local/bin/sync-mako-pywal" ]]; then
            "$HOME/.local/bin/sync-mako-pywal"
            log "‚úÖ Mako sincronizado con colores de pywal"
        else
            log "‚ö†Ô∏è Script sync-mako-pywal no encontrado o no ejecutable"
        fi
        
        # NUEVO: Sincronizaci√≥n MEJORADA de temas de rofi con pywal
        log "üé® PASO 8: Sincronizando temas de rofi con pywal..."
        sync_rofi_with_pywal
        
        # NUEVO: Actualizar temas espec√≠ficos de monitor para rofi
        log "üé® PASO 8.1: Actualizando temas de rofi espec√≠ficos por monitor..."
        if [[ -f "$HOME/.config/rofi/colors.rasi" ]]; then
            # Crear temas pywal para cada monitor espec√≠fico 
            for monitor in "DP-6" "eDP-1"; do
                local monitor_theme="$HOME/.config/rofi/style-3-${monitor}.rasi"
                local monitor_pywal_theme="$HOME/.config/rofi/style-3-pywal-${monitor}.rasi"
                
                if [[ -f "$monitor_theme" ]]; then
                    log "üìã Recreando tema pywal para monitor: $monitor"
                    cp "$monitor_theme" "$monitor_pywal_theme"
                    
                    # A√±adir importaci√≥n de colores pywal y eliminar colores hardcodeados
                    if ! grep -q '@import "colors.rasi"' "$monitor_pywal_theme"; then
                        sed -i 's|@import.*"shared/fonts.rasi"|@import "shared/fonts.rasi"\n@import "colors.rasi"|' "$monitor_pywal_theme"
                    fi
                    
                    # Eliminar colores hardcodeados del tema pywal (reemplazar con comentario)
                    sed -i '/\/\*.*Global Properties.*\*\//,/}/ {
                        /\* {/,/}/ {
                            /background:/d
                            /foreground:/d
                            /color[0-9]\+:/d
                            /\* {/i\
/* Los colores se importan autom√°ticamente desde colors.rasi */
                            /\* {/d
                        }
                    }' "$monitor_pywal_theme"
                    
                    log "‚úÖ Tema pywal actualizado para monitor $monitor"
                fi
            done
            
            # Crear tema pywal base
            log "üìã Recreando tema pywal base"
            cp "$HOME/.config/rofi/style-3.rasi" "$HOME/.config/rofi/style-3-pywal.rasi"
            
            # A√±adir importaci√≥n de colores pywal
            if ! grep -q '@import "colors.rasi"' "$HOME/.config/rofi/style-3-pywal.rasi"; then
                sed -i 's|@import.*"shared/fonts.rasi"|@import "shared/fonts.rasi"\n@import "colors.rasi"|' "$HOME/.config/rofi/style-3-pywal.rasi"
            fi
            
            # Eliminar colores hardcodeados del tema pywal base
            sed -i '/\/\*.*Global Properties.*\*\//,/}/ {
                /\* {/,/}/ {
                    /background:/d
                    /foreground:/d
                    /color[0-9]\+:/d
                    /\* {/i\
/* Los colores se importan autom√°ticamente desde colors.rasi */
                    /\* {/d
                }
            }' "$HOME/.config/rofi/style-3-pywal.rasi"
            
            log "‚úÖ Todos los temas de rofi adaptados para pywal completados"
        else
            log "‚ö†Ô∏è Archivo colors.rasi no encontrado, saltando actualizaci√≥n de temas de monitor"
        fi
        
        # NUEVO: Sincronizaci√≥n autom√°tica con SDDM
        log "üè† PASO 9: Sincronizando con SDDM autom√°ticamente..."
        if [[ -x "$HOME/.local/bin/sddm-auto-sync-local" ]]; then
            # Ejecutar en segundo plano y modo no bloqueante para no retrasar Hyprland ni el flujo del script
            nohup "$HOME/.local/bin/sddm-auto-sync-local" >/dev/null 2>&1 &
            log "‚ñ∂Ô∏è Lanzada sincronizaci√≥n SDDM en background"
        else
            log "‚ö†Ô∏è sddm-auto-sync-local no encontrado o no ejecutable"
        fi
        
        notify "üé® ¬°Wallpaper adaptativo y sistema completamente sincronizado!"
        
    else
        log "‚ùå Error: Pywal fall√≥"
        notify "‚ö†Ô∏è Error en pywal - wallpaper aplicado parcialmente"
    fi
else
    log "‚ÑπÔ∏è Pywal no disponible, solo se aplic√≥ el wallpaper"
    
    # NUEVO: Sincronizaci√≥n autom√°tica con SDDM incluso sin pywal
    log "üè† Sincronizando con SDDM autom√°ticamente (sin pywal)..."
    if [[ -x "$HOME/.local/bin/sddm-auto-sync-local" ]]; then
        # Ejecutar en segundo plano para no bloquear
        nohup "$HOME/.local/bin/sddm-auto-sync-local" >/dev/null 2>&1 &
        log "‚ñ∂Ô∏è Lanzada sincronizaci√≥n SDDM en background (sin pywal)"
    else
        log "‚ö†Ô∏è sddm-auto-sync-local no encontrado o no ejecutable"
    fi
    
    notify "‚ÑπÔ∏è Wallpaper aplicado y SDDM sincronizado"
fi

# Verificaci√≥n final de Waybar
if ! pgrep -x waybar > /dev/null; then
    log "‚ùå CR√çTICO: Waybar no est√° ejecut√°ndose al finalizar. Iniciando respaldo..."
    notify "üîß Iniciando waybar de respaldo..."
    
    nohup waybar > /dev/null 2>&1 &
    sleep 0.5
    
    if pgrep -x waybar > /dev/null; then
        log "‚úÖ RESPALDO EXITOSO: Waybar iniciado correctamente"
        notify "‚úÖ Waybar restaurado exitosamente"
    else
        log "‚ùå FALLO CR√çTICO: No se pudo iniciar waybar"
        notify "‚ùå Error cr√≠tico: No se pudo iniciar waybar"
    fi
else
    log "‚úÖ VERIFICACI√ìN EXITOSA: Waybar est√° ejecut√°ndose correctamente"
fi

log "üéâ === CAMBIO DE WALLPAPER ADAPTATIVO COMPLETADO ==="
log "üì∏ Wallpaper: $(basename "$selected_file")"
log "üñ•Ô∏è Monitor: $ACTIVE_MONITOR"
log "üé® Sistema sincronizado exitosamente"

exit 0
