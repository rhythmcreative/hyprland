#!/bin/bash

# Script optimizado para cambiar wallpaper SIN perder workspaces de waybar
# MÃ©todo mejorado que evita problemas con hyprland/workspaces
# Ejecutado por: Super + Shift + W en Hyprland

set -euo pipefail

WALLPAPER_DIR="$HOME/Pictures/Wallpapers"
CACHE_DIR="$HOME/.cache/wallpaper-previews"
TEMP_FILE="/tmp/rofi_wallpaper_fixed_$$"
LOG_FILE="$HOME/.cache/wallpaper-change-fixed.log"
LOCK_FILE="/tmp/wallpaper-change-fixed.lock"

# FunciÃ³n de logging con timestamp
log() {
    local message="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    # Usar flock para evitar conflictos de escritura cuando rofi estÃ¡ leyendo archivos
    echo "$message" >> "$LOG_FILE"
}

# FunciÃ³n de notificaciÃ³n
notify() {
    notify-send "ğŸ¨ Wallpaper Change" "$1" -t 3000 2>/dev/null || true
}

# Verificar si ya estÃ¡ ejecutÃ¡ndose
if [[ -f "$LOCK_FILE" ]]; then
    lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
        log "â³ Cambio de wallpaper ya en progreso (PID: $lock_pid)"
        exit 0
    fi
fi

# Crear lock
echo $$ > "$LOCK_FILE"

# FunciÃ³n de cleanup - SIMPLIFICADA
cleanup() {
    local exit_code=$?
    
    # Limpiar archivos temporales
    rm -f "$TEMP_FILE"* 2>/dev/null || true
    rm -f "$LOCK_FILE"
    
    # SIMPLIFICADO: Siempre asegurar que waybar estÃ© corriendo si estaba corriendo originalmente
    # No importa en quÃ© punto del script estemos
    if [[ "${ORIGINAL_WAYBAR_STATE:-}" == "running" ]]; then
        # Verificar si waybar estÃ¡ corriendo
        if ! pgrep -x waybar >/dev/null 2>&1; then
            log "ğŸ“± Cleanup: Restaurando Waybar (no estÃ¡ corriendo)..."
            ensure_waybar_running
        else
            log "ğŸ“± Cleanup: Waybar ya estÃ¡ corriendo, no es necesario restaurar"
        fi
    else
        log "ğŸ“± Cleanup: Waybar no estaba corriendo originalmente, no se restaura"
    fi
    
    log "ğŸ§¹ Cleanup completado (exit code: $exit_code)"
}
trap cleanup EXIT INT TERM

# FunciÃ³n para ocultar Waybar (mÃ©todo optimizado para velocidad)
hide_waybar() {
    log "ğŸ“± Ocultando Waybar..."
    
    # MÃ©todo rÃ¡pido: matar directamente
    if pgrep -x waybar > /dev/null; then
        log "ğŸ›‘ Deteniendo waybar..."
        pkill -KILL waybar 2>/dev/null
        sleep 0.1  # Reducido de 0.5 a 0.1
        
        if ! pgrep -x waybar > /dev/null; then
            log "âœ… Waybar detenido rÃ¡pidamente"
            return 0
        fi
    else
        log "â„¹ï¸ Waybar ya estaba detenido"
        return 0
    fi
    
    log "âš ï¸ No se pudo ocultar waybar completamente"
}

# FunciÃ³n para mostrar Waybar (mÃ©todo optimizado para velocidad)
show_waybar() {
    log "ğŸ“± Mostrando Waybar..."
    
    # Verificar si waybar estÃ¡ ejecutÃ¡ndose
    if ! pgrep -x waybar > /dev/null; then
        log "ğŸ”„ Waybar no estÃ¡ ejecutÃ¡ndose, iniciando..."
        # Iniciar waybar en background con nohup
        nohup waybar >/dev/null 2>&1 &
        waybar_pid=$!
        
        # Esperar mÃ­nimo para que inicie
        sleep 0.3  # Reducido de 1.5 a 0.3
        
        if pgrep -x waybar > /dev/null; then
            log "âœ… Waybar iniciado rÃ¡pidamente (PID: $waybar_pid)"
        else
            log "âš ï¸ Waybar tardando en iniciar, continuando..."
            # No esperamos mÃ¡s, continuamos
        fi
    else
        log "â„¹ï¸ Waybar ya estaba ejecutÃ¡ndose"
    fi
}

# FunciÃ³n robusta para asegurar que waybar estÃ© corriendo (para cleanup)
ensure_waybar_running() {
    log "ğŸ”§ Asegurando que waybar estÃ© corriendo..."
    
    # Verificar si waybar estÃ¡ corriendo
    if ! pgrep -x waybar >/dev/null 2>&1; then
        log "ğŸš€ Iniciando waybar..."
        # Intentar con nohup primero
        nohup waybar >/dev/null 2>&1 &
        waybar_pid=$!
        
        # Esperar brevemente
        sleep 0.5
        
        if pgrep -x waybar >/dev/null 2>&1; then
            log "âœ… Waybar iniciado exitosamente (PID: $waybar_pid)"
            return 0
        else
            log "âš ï¸ Primer intento fallÃ³, intentando mÃ©todo directo..."
            # Intentar mÃ©todo directo
            waybar &
            sleep 1
            
            if pgrep -x waybar >/dev/null 2>&1; then
                log "âœ… Waybar iniciado con mÃ©todo directo"
                return 0
            else
                log "âŒ No se pudo iniciar waybar"
                return 1
            fi
        fi
    else
        log "âœ… Waybar ya estÃ¡ corriendo"
        return 0
    fi
}

# Determinar estado original de waybar para manejo correcto en caso de cancelaciÃ³n
if pgrep -x waybar > /dev/null; then
    ORIGINAL_WAYBAR_STATE="running"
    log "ğŸ“ Estado inicial: Waybar estÃ¡ ejecutÃ¡ndose"
else
    ORIGINAL_WAYBAR_STATE="stopped"
    log "ğŸ“ Estado inicial: Waybar no estÃ¡ ejecutÃ¡ndose"
fi

# Inicializar variables de control para evitar reinicios dobles
WAYBAR_ALREADY_RESTARTED="false"
NM_APPLET_ALREADY_RESTARTED="false"

log "ğŸš€ === INICIANDO CAMBIO DE WALLPAPER (MÃ‰TODO FIXED) ==="
notify "Iniciando cambio de wallpaper..."

# Verificar directorio de wallpapers
if [[ ! -d "$WALLPAPER_DIR" ]]; then
    log "ERROR: Directorio $WALLPAPER_DIR no encontrado"
    notify "âŒ Error: Directorio de wallpapers no encontrado"
    exit 1
fi

# Verificar swww
if ! command -v swww &>/dev/null; then
    log "ERROR: swww no estÃ¡ instalado"
    notify "âŒ Error: swww no estÃ¡ instalado"
    exit 1
fi

# Verificar e iniciar swww-daemon si es necesario
if ! pgrep -x "swww-daemon" > /dev/null; then
    log "ğŸš€ Iniciando swww-daemon..."
    swww-daemon --format xrgb &
    # NO sleep - continuar inmediatamente
fi

# Crear directorios necesarios
mkdir -p "$CACHE_DIR"

# Buscar imÃ¡genes
log "ğŸ” Buscando imÃ¡genes en $WALLPAPER_DIR"
cd "$WALLPAPER_DIR" || { log "ERROR: No se pudo acceder a $WALLPAPER_DIR"; exit 1; }

mapfile -t images < <(find . -maxdepth 1 -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.gif" -o -iname "*.webp" -o -iname "*.bmp" \) | sed 's|^./||' | sort)

if [[ ${#images[@]} -eq 0 ]]; then
    log "ERROR: No se encontraron imÃ¡genes"
    notify "âŒ Error: No se encontraron imÃ¡genes"
    exit 1
fi

log "ğŸ“ Encontradas ${#images[@]} imÃ¡genes"

# Crear archivo temporal para rofi
> "$TEMP_FILE"
# FunciÃ³n para generar preview RÃPIDA (cache simple)
generate_preview() {
    local img="$1"
    local clean_name="${img%.*}"
    local safe_name="$(echo "$clean_name" | sed 's/[^a-zA-Z0-9._-]/_/g')"
    local preview_file="$CACHE_DIR/preview_${safe_name}.png"
    
    # Cache simple: Solo verificar si existe
    if [[ -f "$preview_file" ]]; then
        return 0  # Ya existe, usar cache
    fi
    
    # Usar magick en lugar de convert para ImageMagick v7
    local convert_cmd="magick"
    # Fallback a convert si magick no estÃ¡ disponible
    if ! command -v magick &> /dev/null; then
        convert_cmd="convert"
    fi
    
    # Generar preview
    if [[ "$img" == *.gif ]]; then
        # GIF: extraer primer frame y generar preview real
        $convert_cmd "$img[0]" -resize "150x100^" -gravity center -extent "150x100" -strip -quality 60 "$preview_file" 2>/dev/null || {
            # Fallback: usar placeholder si no se puede procesar el GIF
            local placeholder="$HOME/.cache/wal/gif-placeholder.png"
            if [[ ! -f "$placeholder" ]]; then
                $convert_cmd -size 150x100 xc:"#2e3440" -pointsize 12 -fill white -gravity center -annotate +0+0 "GIF" "$placeholder" 2>/dev/null || touch "$placeholder"
            fi
            [[ -f "$placeholder" ]] && cp "$placeholder" "$preview_file" 2>/dev/null
        }
    else
        # Imagen estÃ¡tica: conversiÃ³n rÃ¡pida
        $convert_cmd "$img" -resize "150x100^" -gravity center -extent "150x100" -strip -quality 60 "$preview_file" 2>/dev/null
    fi
    
    return 0
}

# Procesar imÃ¡genes en paralelo para mÃ¡xima velocidad
log "ğŸš€ Generando previews en paralelo..."
pids=()
max_jobs=4  # NÃºmero de trabajos paralelos

# FunciÃ³n para procesar una imagen individual
process_image() {
    local img="$1"
    [[ ! -f "$img" ]] && return
    
    if generate_preview "$img"; then
        local clean_name="${img%.*}"
        local safe_name="$(echo "$clean_name" | sed 's/[^a-zA-Z0-9._-]/_/g')"
        local preview_file="$CACHE_DIR/preview_${safe_name}.png"
        
        # Agregar entrada a archivo temporal individual
        local temp_entry="$TEMP_FILE.$(basename "$img")" 
        if [[ -f "$preview_file" ]]; then
            echo -e "$img\\0icon\\x1f$preview_file" > "$temp_entry"
        else
            echo "$img" > "$temp_entry"
        fi
    fi
}

# Procesar imÃ¡genes SILENCIOSAMENTE para mÃ¡xima velocidad
for img in "${images[@]}"; do
    clean_name="${img%.*}"
    safe_name="$(echo "$clean_name" | sed 's/[^a-zA-Z0-9._-]/_/g')"
    preview_file="$CACHE_DIR/preview_${safe_name}.png"
    
    # Generar preview sin logs detallados
    generate_preview "$img"
    
    # AÃ±adir a archivo rofi
    if [[ -f "$preview_file" ]]; then
        echo -e "$img\\0icon\\x1f$preview_file" >> "$TEMP_FILE"
    else
        echo "$img" >> "$TEMP_FILE"
    fi
done

log "âœ… Procesamiento paralelo completado"

# Verificar que tenemos entradas
if [[ ! -s "$TEMP_FILE" ]]; then
    log "ERROR: No se pudieron procesar las imÃ¡genes"
    notify "âŒ Error: No se pudieron procesar las imÃ¡genes"
    exit 1
fi

log "ğŸ­ Mostrando selector de wallpapers..."

# ===== MÃ‰TODO CONSISTENTE PARA ROFI + WAYBAR =====
log "ğŸ“± Configurando manejo de waybar para rofi..."

# FunciÃ³n para ejecutar rofi con manejo correcto de waybar
execute_rofi_with_waybar() {
    local temp_file="$1"
    local result=""
    local waybar_was_running=false
    
    # Verificar si waybar estÃ¡ ejecutÃ¡ndose antes de iniciarlo
    if pgrep -x waybar > /dev/null; then
        waybar_was_running=true
        log "ğŸ“ Waybar estaba ejecutÃ¡ndose antes de rofi"
    else
        log "ğŸ“ Waybar no estaba ejecutÃ¡ndose antes de rofi"
    fi
    
    log "ğŸ“± Ocultando waybar antes de rofi..."
    hide_waybar
    
    # VerificaciÃ³n rÃ¡pida
    sleep 0.1  # Reducido de 0.5 a 0.1
    if pgrep -x waybar > /dev/null; then
        log "âš ï¸ Waybar sigue ejecutÃ¡ndose, forzando cierre..."
        pkill -KILL waybar 2>/dev/null
        sleep 0.1  # Reducido de 0.3 a 0.1
    fi
    
    log "ğŸš€ Ejecutando rofi..."
    # CRÃTICO: Crear copia completamente aislada para evitar contaminaciÃ³n de logs
    local rofi_temp_file="${temp_file}_rofi_$$"
    
    # ARREGLADO: Crear archivo completamente limpio sin logs
    # Usar exec para redirigir SOLO el output del archivo, no los logs
    {
        exec 3>&1 1>"$rofi_temp_file"  # Redirigir stdout temporalmente
        cat "$temp_file"
        exec 1>&3 3>&-  # Restaurar stdout
    } 2>/dev/null  # Suprimir stderr para evitar contaminaciÃ³n
    
    result=$(rofi -dmenu -i \
        -p "ğŸ–¼ï¸ Seleccionar Wallpaper" \
        -show-icons \
        -theme "$HOME/Downloads/wallpaper-select.rasi" \
        < "$rofi_temp_file" 2>/dev/null || true)
    
    # Limpiar archivo temporal
    rm -f "$rofi_temp_file"
    
    # IMPORTANTE: Solo restaurar Waybar si NO vamos a reiniciarlo despuÃ©s
    # Si pywal estÃ¡ disponible, el reinicio se harÃ¡ en el paso principal
    if [[ "$waybar_was_running" == "true" ]] && ! command -v wal > /dev/null 2>&1; then
        log "ğŸ“± Restaurando waybar despuÃ©s de rofi (sin pywal)..."
        show_waybar
    elif [[ "$waybar_was_running" == "true" ]]; then
        log "ğŸ“± No se restaura waybar ahora - se reiniciarÃ¡ despuÃ©s con pywal"
    else
        log "â„¹ï¸ No se restaura waybar porque no estaba ejecutÃ¡ndose antes"
    fi
    
    echo "$result"
}

# Ejecutar rofi con manejo mejorado
selected=$(execute_rofi_with_waybar "$TEMP_FILE")

# Marcar que Rofi se completÃ³ correctamente
ROFI_COMPLETED="true"

# Si no se seleccionÃ³ nada, salir
if [[ -z "$selected" ]]; then
    log "â„¹ï¸ No se seleccionÃ³ ningÃºn wallpaper"
    exit 0
fi

log "âœ… Seleccionado: $selected"

# ARREGLO: Si la selecciÃ³n contiene texto de log (detectar por formato de timestamp), extraer solo el nombre del archivo
if [[ "$selected" =~ \[20[0-9][0-9]-[0-9][0-9]-[0-9][0-9] ]]; then
    log "âš ï¸ Detectado texto de log en selecciÃ³n, extrayendo nombre del archivo..."
    # Extraer la Ãºltima lÃ­nea que contenga un nombre de archivo vÃ¡lido
    selected=$(echo "$selected" | grep -E '\.(jpg|jpeg|png|gif|webp|bmp)$' | tail -1 | tr -d '\n')
    log "ğŸ”§ Archivo extraÃ­do del log: '$selected'"
fi

# Buscar el archivo correspondiente - ahora seleccionamos el nombre completo
selected_file=""

# Primero intentar bÃºsqueda directa (nombre completo del archivo)
if [[ -f "$WALLPAPER_DIR/$selected" ]]; then
    selected_file="$WALLPAPER_DIR/$selected"
    log "ğŸ¯ Archivo encontrado directamente: $selected_file"
else
    # Fallback: buscar por nombre sin extensiÃ³n (compatibilidad)
    for img in "${images[@]}"; do
        if [[ "${img%.*}" == "$selected" ]]; then
            selected_file="$WALLPAPER_DIR/$img"
            log "ğŸ¯ Archivo encontrado por fallback: $selected_file"
            break
        fi
    done
fi

# Verificar archivo seleccionado
if [[ -z "$selected_file" ]] || [[ ! -f "$selected_file" ]]; then
    log "âŒ ERROR: Archivo no encontrado: $selected"
    log "ğŸ” Debug info:"
    log "   - SelecciÃ³n: '$selected'"
    log "   - Directorio: '$WALLPAPER_DIR'"
    log "   - Archivos disponibles:"
    for img in "${images[@]}"; do
        log "     * '$img'"
    done
    notify "âŒ Error: Archivo no encontrado"
    exit 1
fi

# ===== APLICACIÃ“N MEJORADA DEL WALLPAPER =====

log "ğŸ–¼ï¸ PASO 1: Aplicando wallpaper: $selected_file"

# 1. Aplicar wallpaper con swww
if swww img "$selected_file" --transition-type grow --transition-pos "0.9,0.1" --transition-duration 1.5; then
    log "âœ… Wallpaper aplicado con swww"
    notify "ğŸ–¼ï¸ Wallpaper aplicado: $(basename "$selected_file")"
else
    log "âŒ Error al aplicar wallpaper con swww"
    exit 1
fi

# 2. Los monitores se configurarÃ¡n automÃ¡ticamente al recargar Hyprland config
log "ğŸ–¥ï¸ PASO 1.5: Los monitores se configurarÃ¡n con hyprctl reload..."

# 3. Guardar wallpaper actual
echo "$selected_file" > "$HOME/.cache/current-wallpaper"

# 4. Aplicar pywal SOLO si estÃ¡ disponible
if command -v wal > /dev/null 2>&1; then
    log "ğŸ¨ PASO 2: Aplicando colores con pywal..."
    notify "ğŸŒˆ Generando colores con pywal..."
    
    if wal -i "$selected_file" -n -q; then
        log "âœ… Pywal aplicado exitosamente"
        
        # Esperar a que pywal genere todos los archivos - reducido
        sleep 0.5
        
        # 5. Actualizar archivo de colores para Waybar
        log "ğŸ¨ PASO 3: Actualizando colores de Waybar..."
        if [[ -f "$HOME/.cache/wal/colors-waybar.css" ]]; then
            cp "$HOME/.cache/wal/colors-waybar.css" "$HOME/.config/waybar/colors-pywal.css"
            log "âœ… Archivo colors-waybar.css copiado"
        elif [[ -f "$HOME/.cache/wal/colors.css" ]]; then
            # Si no hay colors-waybar.css, generar desde colors.css
            cat > "$HOME/.config/waybar/colors-pywal.css" <<EOF
/* Colores generados automÃ¡ticamente por pywal */
$(grep -E '^--color[0-9]+|^--background|^--foreground|^--cursor' "$HOME/.cache/wal/colors.css" | sed 's/--/@define-color /' | sed 's/: / /g' | sed 's/;//g')
EOF
            log "âœ… Archivo colors-pywal.css generado desde colors.css"
        else
            # Generar desde colors.sh si no hay CSS
            source "$HOME/.cache/wal/colors.sh"
            cat > "$HOME/.config/waybar/colors-pywal.css" <<EOF
/* Colores generados automÃ¡ticamente por pywal */
@define-color background $background;
@define-color foreground $foreground;
@define-color cursor $cursor;
@define-color color0 $color0;
@define-color color1 $color1;
@define-color color2 $color2;
@define-color color3 $color3;
@define-color color4 $color4;
@define-color color5 $color5;
@define-color color6 $color6;
@define-color color7 $color7;
@define-color color8 $color8;
@define-color color9 $color9;
@define-color color10 $color10;
@define-color color11 $color11;
@define-color color12 $color12;
@define-color color13 $color13;
@define-color color14 $color14;
@define-color color15 $color15;
EOF
            log "âœ… Archivo colors-pywal.css generado desde colors.sh"
        fi
        
        # 5. NUEVO: Generar configuraciÃ³n segura de monitores antes del reload
        log "ğŸ–¥ï¸ PASO 4A: Generando configuraciÃ³n segura de monitores..."
        if [[ -x "$HOME/.local/bin/safe-monitor-config" ]]; then
            if "$HOME/.local/bin/safe-monitor-config" generate > /dev/null 2>&1; then
                log "âœ… ConfiguraciÃ³n de monitores actualizada de forma segura"
            else
                log "âš ï¸ Advertencia: No se pudo generar configuraciÃ³n segura de monitores"
                # Continuar de cualquier manera, pero ser mÃ¡s cuidadoso con el reload
            fi
        else
            log "âš ï¸ Script safe-monitor-config no encontrado, usando configuraciÃ³n existente"
        fi
        
        # 5. Recargar Hyprland config (para obtener nuevos colores) - AHORA MÃS SEGURO
        log "ğŸ”„ PASO 4B: Recargando configuraciÃ³n de Hyprland de forma segura..."
        
        # Verificar que no hay instancias problemÃ¡ticas antes del reload
        monitor_count=$(hyprctl monitors | grep -c "^Monitor" || echo "1")
        log "ğŸ“º Monitores detectados antes del reload: $monitor_count"
        
        # Intentar reload con manejo de errores mejorado
        if timeout 10s hyprctl reload > /dev/null 2>&1; then
            log "âœ… ConfiguraciÃ³n de Hyprland recargada exitosamente"
            
            # Verificar que Hyprland sigue funcionando despuÃ©s del reload
            sleep 0.5
            if ! hyprctl version > /dev/null 2>&1; then
                log "âŒ CRÃTICO: Hyprland no responde despuÃ©s del reload"
                notify "âš ï¸ Error: Problema con Hyprland despuÃ©s de recargar configuraciÃ³n"
            else
                log "âœ… Hyprland funcionando correctamente despuÃ©s del reload"
            fi
        else
            log "âŒ WARNING: No se pudo recargar Hyprland o timeout alcanzado"
            notify "âš ï¸ Advertencia: Problema al recargar configuraciÃ³n de Hyprland"
            
            # Verificar si Hyprland sigue funcionando
            if ! hyprctl version > /dev/null 2>&1; then
                log "âŒ CRÃTICO: Hyprland no responde - posible crash"
                notify "âŒ Error crÃ­tico: Hyprland puede haber fallado"
                # En este punto, el sistema deberÃ­a estar regresando a sddm
                exit 1
            fi
        fi
        
        # 6. MÃ‰TODO MEJORADO: Reiniciar Waybar UNA SOLA VEZ
        log "ğŸ“± PASO 5: Reiniciando Waybar una sola vez..."
        
        # Variable de control para evitar reinicio doble
        if [[ "${WAYBAR_ALREADY_RESTARTED:-}" == "true" ]]; then
            log "â„¹ï¸ Waybar ya fue reiniciado anteriormente, omitiendo paso..."
        else
            # Marcar waybar como ya reiniciado
            WAYBAR_ALREADY_RESTARTED="true"
            
            # Verificar si waybar estÃ¡ ejecutÃ¡ndose
            waybar_count=$(pgrep -x waybar | wc -l)
            log "ğŸ” Instancias de waybar detectadas: $waybar_count"
            
            if [[ $waybar_count -gt 0 ]]; then
                log "ğŸ›‘ Cerrando todas las instancias de waybar..."
                # Cerrar waybar limpiamente
                pkill -TERM waybar 2>/dev/null || true
                
                # MÃ©todo ultra-rÃ¡pido: matar inmediatamente y reiniciar
                log "ğŸ›‘ Cerrando todas las instancias de waybar rÃ¡pido..."
                pkill -KILL waybar 2>/dev/null || true
                sleep 0.1  # Solo esperar 0.1 segundos
            fi
            
            # Iniciar waybar inmediatamente
            log "ğŸš€ Iniciando nueva instancia de waybar..."
            nohup waybar > /dev/null 2>&1 &
            waybar_pid=$!
            
            # Esperar mÃ­nimo para que inicie - reducido drÃ¡sticamente
            sleep 0.8  # Reducido de 3 a 0.8 segundos
            
            if pgrep -x waybar > /dev/null; then
                log "âœ… Waybar reiniciado exitosamente (PID: $waybar_pid)"
                
                # VerificaciÃ³n rÃ¡pida de workspaces - sin sleep adicional
                log "ğŸ” Verificando mÃ³dulo de workspaces..."
                if hyprctl workspaces | grep -q "workspace ID"; then
                    log "âœ… MÃ³dulo de workspaces funcionando correctamente"
                else
                    log "âš ï¸ Advertencia: No se pudo verificar el estado de workspaces"
                fi
            else
                log "âŒ Error: Waybar no se iniciÃ³ correctamente"
                notify "âš ï¸ Error: Waybar no se iniciÃ³ despuÃ©s de aplicar colores"
            fi
        fi
        
        # 7. Configurar temas GTK (despuÃ©s de pywal) - sin delay
        log "ğŸ¨ PASO 6: Configurando temas GTK..."
        
        # Aplicar tema Arc-Dark
        if gsettings set org.gnome.desktop.interface gtk-theme "Arc-Dark" 2>/dev/null; then
            log "âœ… Tema GTK Arc-Dark aplicado"
        else
            log "âš ï¸ No se pudo aplicar Arc-Dark, usando tema predeterminado"
        fi
        
        # Aplicar iconos Tela circle black
        if gsettings set org.gnome.desktop.interface icon-theme "Tela-circle-black-dark" 2>/dev/null; then
            log "âœ… Tema de iconos Tela-circle-black-dark aplicado"
        else
            log "âš ï¸ No se pudo aplicar Tela-circle-black-dark, usando tema predeterminado"
        fi
        
        # Exportar variables de entorno
        export GTK_THEME="Arc-Dark"
        
        log "âœ… Temas GTK configurados correctamente"
        
        # 8. OPTIMIZADO: Reinicio UNA SOLA VEZ de nm-applet
        log "ğŸŒ PASO 7: Reinicio Ãºnico de nm-applet..."
        
        # Variable de control para evitar reinicio doble
        if [[ "${NM_APPLET_ALREADY_RESTARTED:-}" == "true" ]]; then
            log "â„¹ï¸ nm-applet ya fue reiniciado anteriormente, omitiendo paso..."
        else
            # Marcar nm-applet como ya reiniciado
            NM_APPLET_ALREADY_RESTARTED="true"
            
            # MÃ©todo ultra-rÃ¡pido: matar inmediatamente y reiniciar
            if pgrep -x nm-applet > /dev/null; then
                log "ğŸ”„ Cerrando nm-applet existente..."
                pkill -9 nm-applet 2>/dev/null || true
                sleep 0.2  # Solo 0.2 segundos
            fi
            
            # Iniciar nm-applet inmediatamente con --indicator para mÃ¡xima velocidad
            log "ğŸš€ Iniciando nm-applet optimizado..."
            nm-applet --indicator > /dev/null 2>&1 &
            nm_pid=$!
            
            # VerificaciÃ³n ultra-rÃ¡pida - solo 0.2 segundos total
            sleep 0.2
            
            if pgrep -x nm-applet > /dev/null; then
                log "âœ… nm-applet reiniciado rÃ¡pidamente (PID: $nm_pid)"
            else
                log "âš ï¸ Reintentando nm-applet..."
                nm-applet --indicator &
                sleep 0.3
                pgrep -x nm-applet > /dev/null && log "âœ… nm-applet iniciado en segundo intento" || log "âŒ nm-applet fallÃ³"
            fi
        fi
        
        # 9. NUEVO: Sincronizar terminales (Kitty + Oh My Posh + P10k)
        log "ğŸ–¥ï¸ PASO 8: Sincronizando terminales con pywal..."
        
        if [[ -x "$HOME/.local/bin/sync-terminals-pywal" ]]; then
            log "ğŸ”„ Ejecutando sync-terminals-pywal..."
            if "$HOME/.local/bin/sync-terminals-pywal"; then
                log "âœ… Terminales sincronizados exitosamente"
            else
                log "âš ï¸ Advertencia: Error en sync-terminals-pywal"
            fi
        else
            log "âš ï¸ Script sync-terminals-pywal no encontrado"
            
            # Fallback: sincronizar solo Kitty bÃ¡sicamente
            if [[ -f "$HOME/.cache/wal/colors-kitty.conf" ]]; then
                log "ğŸ± Fallback: Kitty ya tiene colores de pywal"
            fi
        fi
        
        # 10. NUEVO: SincronizaciÃ³n con pywalfox
        log "ğŸ¦Š PASO 9: Sincronizando con pywalfox..."
        
        if command -v pywalfox > /dev/null 2>&1; then
            log "ğŸ¨ Ejecutando pywalfox update..."
            if pywalfox update > /dev/null 2>&1; then
                log "âœ… pywalfox sincronizado exitosamente"
            else
                log "âš ï¸ Advertencia: Error en pywalfox update"
            fi
        else
            log "âš ï¸ pywalfox no estÃ¡ disponible en PATH"
        fi
        
        # 11. NUEVO: SincronizaciÃ³n automÃ¡tica con pywal-auto-sync
        log "ğŸ”„ PASO 10: Sincronizando con pywal-auto-sync..."
        
        if [[ -x "$HOME/.local/bin/pywal-auto-sync" ]]; then
            log "ğŸ¨ Ejecutando pywal-auto-sync sync..."
            if "$HOME/.local/bin/pywal-auto-sync" sync; then
                log "âœ… pywal-auto-sync sincronizado exitosamente"
            else
                log "âš ï¸ Advertencia: Error en pywal-auto-sync"
            fi
        else
            log "âš ï¸ Script pywal-auto-sync no encontrado en $HOME/.local/bin/"
        fi
        
        # 12. NUEVO: SincronizaciÃ³n de hyprlock con pywal
        log "ğŸ”’ PASO 11: Sincronizando hyprlock con pywal..."
        
        # Generar colores mejorados para Hyprland/hyprlock
        if [[ -x "$HOME/.local/bin/hyprland-pywal-colors" ]]; then
            log "ğŸ¨ Generando colores para hyprlock..."
            if "$HOME/.local/bin/hyprland-pywal-colors"; then
                log "âœ… Colores de hyprlock generados exitosamente"
                
                # Verificar que el archivo se creÃ³ correctamente
                if [[ -f "$HOME/.cache/wal/colors-hyprland-enhanced.conf" ]]; then
                    log "âœ… Archivo colors-hyprland-enhanced.conf confirmado"
                    # Opcional: recargar hyprlock si estÃ¡ activo (solo si es necesario)
                    if pgrep -x hyprlock > /dev/null; then
                        log "â„¹ï¸ hyprlock estÃ¡ activo, los nuevos colores se aplicarÃ¡n en el prÃ³ximo bloqueo"
                    fi
                else
                    log "âš ï¸ Advertencia: No se pudo crear colors-hyprland-enhanced.conf"
                fi
            else
                log "âš ï¸ Advertencia: Error al generar colores para hyprlock"
            fi
        else
            log "âš ï¸ Script hyprland-pywal-colors no encontrado"
        fi
        
        notify "ğŸ¨ Â¡Wallpaper y sistema completamente sincronizado!"
        log "ğŸ”’ hyprlock sincronizado: Los colores se aplicarÃ¡n en el prÃ³ximo bloqueo de pantalla"
        
    else
        log "âŒ Error: Pywal fallÃ³"
        notify "âš ï¸ Error en pywal - wallpaper aplicado parcialmente"
    fi
else
    log "â„¹ï¸ Pywal no disponible, solo se aplicÃ³ el wallpaper"
    notify "â„¹ï¸ Solo wallpaper aplicado (pywal no disponible)"
fi

# VERIFICACIÃ“N FINAL DE WAYBAR - OPTIMIZADA
if ! pgrep -x waybar > /dev/null; then
    log "âŒ CRÃTICO: Waybar no estÃ¡ ejecutÃ¡ndose al finalizar. Iniciando respaldo..."
    notify "ğŸ”§ Iniciando waybar de respaldo..."
    
    # Intentar iniciar waybar de respaldo
    nohup waybar > /dev/null 2>&1 &
    waybar_fallback_pid=$!
    
    # VerificaciÃ³n RÃPIDA - solo 0.5 segundos
    sleep 0.5
    
    if pgrep -x waybar > /dev/null; then
        log "âœ… RESPALDO EXITOSO: Waybar iniciado correctamente (PID: $waybar_fallback_pid)"
        notify "âœ… Waybar restaurado exitosamente"
    else
        log "âŒ FALLO CRÃTICO: No se pudo iniciar waybar incluso con respaldo"
        notify "âŒ Error crÃ­tico: No se pudo iniciar waybar"
        
        # Intentar un Ãºltimo intento con mÃ©todo diferente
        log "ğŸ”„ ÃšLTIMO INTENTO: Intentando con systemctl o mÃ©todo alternativo..."
        
        # Verificar si hay un servicio de waybar
        if systemctl --user is-active --quiet waybar.service 2>/dev/null; then
            log "ğŸ”„ Reiniciando servicio waybar..."
            systemctl --user restart waybar.service
        else
            log "ğŸ”„ Ãšltimo intento directo..."
            waybar &
            sleep 1
        fi
        
        # VerificaciÃ³n final
        if pgrep -x waybar > /dev/null; then
            log "âœ… ÃšLTIMO INTENTO EXITOSO: Waybar finalmente iniciado"
        else
            log "âŒ FALLO TOTAL: Waybar no se pudo iniciar. Puede requerir intervenciÃ³n manual."
            notify "âš ï¸ Waybar fallÃ³ - inicia manualmente: waybar &"
        fi
    fi
else
    log "âœ… VERIFICACIÃ“N EXITOSA: Waybar estÃ¡ ejecutÃ¡ndose correctamente"
fi

log "ğŸ‰ === CAMBIO DE WALLPAPER COMPLETADO ==="
log "ğŸ“¸ Wallpaper: $(basename "$selected_file")"
log "ğŸ¨ Sistema sincronizado exitosamente con waybar reiniciado"

exit 0
