#!/bin/bash

# Script completo para cambiar wallpaper adaptativamente y sincronizar con SDDM
# Basado en wallpaper-change-adaptive con integraciÃ³n completa de sddm-auto-sync-local
# Ejecutado por: Super + Shift + W en Hyprland o llamado directamente

set -euo pipefail

WALLPAPER_DIR="$HOME/Pictures/Wallpapers"
CACHE_DIR="$HOME/.cache/wallpaper-previews"
TEMP_FILE="/tmp/rofi_wallpaper_adaptive_$$"
LOG_FILE="$HOME/.cache/wallpaper-change-sddm-sync.log"
LOCK_FILE="/tmp/wallpaper-change-sddm-sync.lock"

# FunciÃ³n de logging con timestamp
log() {
    local message="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    echo "$message" | tee -a "$LOG_FILE"
}

# FunciÃ³n de notificaciÃ³n
notify() {
    notify-send "ğŸ¨ Wallpaper & SDDM Sync" "$1" -t 3000 2>/dev/null || true
}

# Verificar si ya estÃ¡ ejecutÃ¡ndose
if [[ -f "$LOCK_FILE" ]]; then
    lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
        log "â³ Cambio de wallpaper ya en progreso (PID: $lock_pid)"
        exit 0
    fi
fi

# Crear lock
echo $$ > "$LOCK_FILE"

# ParÃ¡metros del script
WALLPAPER_PATH="${1:-}"
FORCE_SYNC="${2:-false}"

# Si se proporciona un wallpaper especÃ­fico, procesarlo
if [ -n "$WALLPAPER_PATH" ]; then
    if [ ! -f "$WALLPAPER_PATH" ]; then
        log "âŒ Error: El archivo '$WALLPAPER_PATH' no existe"
        notify "âŒ Error: Archivo no encontrado"
        exit 1
    fi
    
    log "ğŸ–¼ï¸ Cambiando wallpaper y sincronizando con SDDM..."
    log "ğŸ“ Wallpaper: $WALLPAPER_PATH"
    
    # Aplicar wallpaper con swww y generar colores con pywal
    log "ğŸ¨ Generando colores con pywal..."
    if wal -i "$WALLPAPER_PATH" -n -q; then
        log "âœ… Pywal aplicado exitosamente"
    else
        log "âŒ Error aplicando pywal"
    fi
    
    log "ğŸŒŠ Aplicando wallpaper con swww..."
    if swww img "$WALLPAPER_PATH" --transition-fps 60 --transition-type wipe --transition-duration 0.5; then
        log "âœ… Wallpaper aplicado con swww"
        notify "ğŸ–¼ï¸ Wallpaper aplicado: $(basename "$WALLPAPER_PATH")"
    else
        log "âŒ Error aplicando wallpaper con swww"
    fi
    
    # Guardar wallpaper actual
    echo "$WALLPAPER_PATH" > "$HOME/.cache/current-wallpaper"
    
# Esperar un momento para que pywal y swww terminen
    sleep 2
    
    # Saltar al procesamiento directo si se proporcionÃ³ un archivo
    DIRECT_FILE_PROCESSING=true
else
    DIRECT_FILE_PROCESSING=false
fi

# FunciÃ³n para detectar el monitor activo basado en posiciÃ³n del cursor
get_active_monitor() {
    # PRIORIDAD 1: Detectar por posiciÃ³n del cursor
    local cursor_info=$(hyprctl cursorpos 2>/dev/null)
    if [ -n "$cursor_info" ]; then
        local cursor_x=$(echo "$cursor_info" | cut -d',' -f1 | tr -d ' ')
        local cursor_y=$(echo "$cursor_info" | cut -d',' -f2 | tr -d ' ')
        
        log "Cursor en coordenadas: ($cursor_x, $cursor_y)"
        
        # Obtener informaciÃ³n de todos los monitores
        local monitors=$(hyprctl monitors -j 2>/dev/null)
        
        if [ -n "$monitors" ]; then
            local cursor_monitor=$(echo "$monitors" | jq -r --arg cx "$cursor_x" --arg cy "$cursor_y" '
                .[] | select(
                    ($cx | tonumber) >= .x and 
                    ($cx | tonumber) < (.x + .width) and 
                    ($cy | tonumber) >= .y and 
                    ($cy | tonumber) < (.y + .height)
                ) | .name' 2>/dev/null | head -n1)
            
            if [ -n "$cursor_monitor" ] && [ "$cursor_monitor" != "null" ]; then
                log "Monitor detectado por cursor: $cursor_monitor"
                echo "$cursor_monitor"
                return
            fi
        fi
    fi
    
    # Fallback: usar el monitor principal/focused
    local focused_monitor=$(hyprctl monitors -j 2>/dev/null | jq -r '.[] | select(.focused == true) | .name' 2>/dev/null)
    if [ -n "$focused_monitor" ] && [ "$focused_monitor" != "null" ]; then
        log "Monitor detectado como focused: $focused_monitor"
        echo "$focused_monitor"
        return
    fi
    
    # Ãšltimo recurso
    log "No se pudo detectar monitor, usando eDP-1 por defecto"
    echo "eDP-1"
}

# FunciÃ³n para sincronizar rofi con pywal
sync_rofi_with_pywal() {
    log "ğŸ¨ Iniciando sincronizaciÃ³n optimizada de rofi con pywal..."
    
    # Verificar que pywal generÃ³ el archivo colors-rofi.rasi
    if [[ -f "$HOME/.cache/wal/colors-rofi.rasi" ]]; then
        log "âœ… Archivo colors-rofi.rasi generado por pywal"
        
        # Copiar archivo de colores al directorio de configuraciÃ³n de rofi
        mkdir -p "$HOME/.config/rofi"
        cp "$HOME/.cache/wal/colors-rofi.rasi" "$HOME/.config/rofi/colors-pywal.rasi"
        log "ğŸ“‹ Colores de rofi copiados a ~/.config/rofi/colors-pywal.rasi"
        
        # Generar versiones optimizadas con colores pywal para temas existentes
        for theme_file in "$HOME/Downloads/style-3.rasi" "$HOME/Downloads/wallpaper-select.rasi"; do
            if [[ -f "$theme_file" ]]; then
                local theme_name=$(basename "$theme_file" .rasi)
                local pywal_theme="$HOME/.config/rofi/${theme_name}-pywal.rasi"
                
                log "ğŸ“‹ Creando versiÃ³n pywal optimizada de tema: $theme_name"
                
                # Crear versiÃ³n optimizada que use los colores de pywal
                create_optimized_pywal_theme "$theme_file" "$pywal_theme"
            fi
        done
        
        log "âœ… Todos los temas de rofi sincronizados con pywal"
        return 0
    else
        log "âš ï¸ colors-rofi.rasi no generado por pywal"
        return 1
    fi
}

# FunciÃ³n para crear temas optimizados que respeten completamente pywal
create_optimized_pywal_theme() {
    local original_theme="$1"
    local pywal_theme="$2"
    local temp_file="$(mktemp)"
    
    log "ğŸ”§ Creando tema optimizado: $(basename "$pywal_theme")"
    
    # Validar que el tema original existe
    if [[ ! -f "$original_theme" ]]; then
        log "âŒ ERROR: Tema original no encontrado: $original_theme"
        return 1
    fi
    
    # Escribir importaciÃ³n de colores pywal al principio
    echo '@import "colors-pywal.rasi"' > "$temp_file"
    echo '' >> "$temp_file"
    
    # Procesar el archivo original, eliminando COMPLETAMENTE colores hardcodeados
    local in_color_section=false
    local brace_count=0
    
    while IFS= read -r line; do
        # Detectar inicio de secciÃ³n de colores
        if [[ "$line" =~ ^[[:space:]]*\*[[:space:]]*\{[[:space:]]*$ ]]; then
            echo "$line" >> "$temp_file"
            in_color_section=true
            brace_count=1
            echo "    /* Los colores se importan automÃ¡ticamente desde colors-pywal.rasi */" >> "$temp_file"
            continue
        fi
        
        # Contar llaves para saber cuÃ¡ndo termina la secciÃ³n
        if [[ "$in_color_section" == "true" ]]; then
            if [[ "$line" == *"{"* ]]; then
                ((brace_count++))
            fi
            if [[ "$line" == *"}"* ]]; then
                ((brace_count--))
                if [[ $brace_count -eq 0 ]]; then
                    in_color_section=false
                    echo "$line" >> "$temp_file"
                    continue
                fi
            fi
        fi
        
        # Si estamos en la secciÃ³n de colores, omitir colores hardcodeados
        if [[ "$in_color_section" == "true" ]]; then
            if [[ "$line" =~ ^[[:space:]]*(bgcolor|background|background-alt|foreground|foreground-alt|selected|active|urgent|color[0-9]+)[[:space:]]*:[[:space:]]*#[0-9A-Fa-f]+ ]] || 
               [[ "$line" =~ ^[[:space:]]*(bgcolor|background|background-alt|foreground|foreground-alt|selected|active|urgent|color[0-9]+)[[:space:]]*:[[:space:]]*rgba\( ]]; then
                # Omitir completamente (no incluir ni como comentario)
                continue
            fi
        fi
        
        # Incluir todas las demÃ¡s lÃ­neas
        echo "$line" >> "$temp_file"
    done < "$original_theme"
    
    # Verificar que el archivo se generÃ³ correctamente
    if [[ -s "$temp_file" ]]; then
        # Mover archivo temporal al destino final
        mv "$temp_file" "$pywal_theme"
        log "âœ… Tema optimizado creado: $(basename "$pywal_theme")"
        return 0
    else
        log "âŒ ERROR: No se pudo generar el tema optimizado"
        rm -f "$temp_file"
        return 1
    fi
}

# FunciÃ³n para ocultar Waybar
hide_waybar() {
    log "ğŸ“± Ocultando Waybar..."
    if pgrep -x waybar > /dev/null; then
        pkill -KILL waybar 2>/dev/null
        sleep 0.1
        log "âœ… Waybar detenido"
    fi
}

# FunciÃ³n para mostrar Waybar
show_waybar() {
    log "ğŸ“± Mostrando Waybar..."
    if ! pgrep -x waybar > /dev/null; then
        nohup waybar > /dev/null 2>&1 &
        sleep 0.3
        if pgrep -x waybar > /dev/null; then
            log "âœ… Waybar iniciado"
        fi
    fi
}

# FunciÃ³n de cleanup
cleanup() {
    local exit_code=$?
    
    # Limpiar archivos temporales
    rm -f "$TEMP_FILE"* 2>/dev/null || true
    rm -f "$LOCK_FILE"
    
    # Restaurar Waybar si estaba corriendo
    if [[ "${ORIGINAL_WAYBAR_STATE:-}" == "running" ]]; then
        if ! pgrep -x waybar > /dev/null 2>&1; then
            log "ğŸ“± Cleanup: Restaurando Waybar..."
            show_waybar
        fi
    fi
    
    log "ğŸ§¹ Cleanup completado (exit code: $exit_code)"
}
trap cleanup EXIT INT TERM

# Determinar estado original de waybar
if pgrep -x waybar > /dev/null; then
    ORIGINAL_WAYBAR_STATE="running"
    log "ğŸ“ Estado inicial: Waybar estÃ¡ ejecutÃ¡ndose"
else
    ORIGINAL_WAYBAR_STATE="stopped"
    log "ğŸ“ Estado inicial: Waybar no estÃ¡ ejecutÃ¡ndose"
fi

# Si se procesa un archivo directamente, saltar al procesamiento final
if [[ "$DIRECT_FILE_PROCESSING" == "true" ]]; then
    log "ğŸ¯ Procesamiento directo de archivo, saltando a sincronizaciÃ³n..."
    selected_file="$WALLPAPER_PATH"
else
    # Detectar monitor activo para selecciÃ³n interactiva
    ACTIVE_MONITOR=$(get_active_monitor)
    log "Monitor activo detectado: $ACTIVE_MONITOR"
    
    log "ğŸš€ === INICIANDO SELECTOR DE WALLPAPER ADAPTATIVO ==="
    log "ğŸ–¥ï¸ Monitor activo: $ACTIVE_MONITOR"
    notify "Iniciando selector de wallpapers adaptativo..."
    
    # Verificar directorio de wallpapers
    if [[ ! -d "$WALLPAPER_DIR" ]]; then
        log "ERROR: Directorio $WALLPAPER_DIR no encontrado"
        notify "âŒ Error: Directorio de wallpapers no encontrado"
        exit 1
    fi
    
    # Verificar swww
    if ! command -v swww &> /dev/null; then
        log "ERROR: swww no estÃ¡ instalado"
        notify "âŒ Error: swww no estÃ¡ instalado"
        exit 1
    fi
    
    # Verificar e iniciar swww-daemon si es necesario
    if ! pgrep -x "swww-daemon" > /dev/null; then
        log "ğŸš€ Iniciando swww-daemon..."
        swww-daemon --format xrgb &
    fi
    
    # Crear directorios necesarios
    mkdir -p "$CACHE_DIR"
    
    # Buscar imÃ¡genes
    log "ğŸ” Buscando imÃ¡genes en $WALLPAPER_DIR"
    cd "$WALLPAPER_DIR" || { log "ERROR: No se pudo acceder a $WALLPAPER_DIR"; exit 1; }
    
    mapfile -t images < <(find . -maxdepth 1 -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.gif" -o -iname "*.webp" -o -iname "*.bmp" \) | sed 's|^./||' | sort)
    
    if [[ ${#images[@]} -eq 0 ]]; then
        log "ERROR: No se encontraron imÃ¡genes"
        notify "âŒ Error: No se encontraron imÃ¡genes"
        exit 1
    fi
    
    log "ğŸ“ Encontradas ${#images[@]} imÃ¡genes"
    
    # Configurar tema de Rofi segÃºn el monitor con soporte para pywal
    configure_rofi_theme() {
        local monitor="$1"
        local rofi_theme=""
        local rofi_config=""
        local theme_name="wallpaper-select"
        local pywal_theme="$HOME/.config/rofi/${theme_name}-pywal.rasi"
        local fallback_theme="$HOME/Downloads/${theme_name}.rasi"
        
        # Prioridad 1: Usar tema sincronizado con pywal si existe y pywal estÃ¡ activo
        if [[ -f "$pywal_theme" ]] && [[ -f "$HOME/.cache/wal/colors-rofi.rasi" ]] && command -v wal > /dev/null 2>&1; then
            rofi_theme="$pywal_theme"
            log "ğŸ¨ Usando tema sincronizado con pywal: $theme_name-pywal.rasi"
        # Prioridad 2: Usar tema original como fallback
        elif [[ -f "$fallback_theme" ]]; then
            rofi_theme="$fallback_theme"
            log "âš ï¸ Usando tema original (pywal no disponible): $theme_name.rasi"
        else
            log "âŒ ERROR: No se encontrÃ³ ningÃºn tema de rofi disponible"
            rofi_theme=""
        fi
        
        # Configurar parÃ¡metros especÃ­ficos del monitor
        case "$monitor" in
            "DP-6")
                if [[ -n "$rofi_theme" ]]; then
                    rofi_config="-theme '$rofi_theme' -font 'Inter 12' -width 900 -lines 15"
                    log "ğŸ“º ConfiguraciÃ³n optimizada para DP-6 (2560x1440) con tema: $(basename "$rofi_theme")"
                else
                    rofi_config="-font 'Inter 12' -width 900 -lines 15"
                    log "ğŸ“º ConfiguraciÃ³n bÃ¡sica para DP-6 (sin tema especÃ­fico)"
                fi
                ;;
            "eDP-1")
                if [[ -n "$rofi_theme" ]]; then
                    rofi_config="-theme '$rofi_theme' -font 'Inter 10' -width 700 -lines 12"
                    log "ğŸ’» ConfiguraciÃ³n optimizada para eDP-1 (1920x1080) con tema: $(basename "$rofi_theme")"
                else
                    rofi_config="-font 'Inter 10' -width 700 -lines 12"
                    log "ğŸ’» ConfiguraciÃ³n bÃ¡sica para eDP-1 (sin tema especÃ­fico)"
                fi
                ;;
            *)
                if [[ -n "$rofi_theme" ]]; then
                    rofi_config="-theme '$rofi_theme' -font 'Inter 11' -width 800 -lines 13"
                    log "ğŸ–¥ï¸ ConfiguraciÃ³n por defecto para monitor: $monitor con tema: $(basename "$rofi_theme")"
                else
                    rofi_config="-font 'Inter 11' -width 800 -lines 13"
                    log "ğŸ–¥ï¸ ConfiguraciÃ³n bÃ¡sica para monitor: $monitor (sin tema especÃ­fico)"
                fi
                ;;
        esac
        
        echo "$rofi_config"
    }
    
    # FunciÃ³n para obtener tamaÃ±os de preview segÃºn el monitor
    get_preview_size() {
        local monitor="$1"
        
        case "$monitor" in
            "DP-6")
                # Monitor 2560x1440 - previews mÃ¡s grandes
                echo "200x133"  # ProporciÃ³n 3:2, mÃ¡s grande para monitor grande
                ;;
            "eDP-1")
                # Monitor 1920x1080 - previews mÃ¡s pequeÃ±os
                echo "120x80"   # ProporciÃ³n 3:2, mÃ¡s pequeÃ±o para laptop
                ;;
            *)
                # Fallback - tamaÃ±o medio
                echo "150x100"
                ;;
        esac
    }
    
    # FunciÃ³n para generar preview rÃ¡pida adaptativa segÃºn monitor
    generate_preview() {
        local img="$1"
        local monitor="$2"
        local preview_size=$(get_preview_size "$monitor")
        local clean_name="${img%.*}"
        local safe_name="$(echo "$clean_name" | sed 's/[^a-zA-Z0-9._-]/_/g')"
        local preview_file="$CACHE_DIR/preview_${safe_name}_${monitor}.png"
        
        log "ğŸ–¼ï¸ Generando preview $preview_size para monitor $monitor: $img"
        
        # Cache especÃ­fico por monitor: verificar si existe para este monitor y tamaÃ±o
        if [[ -f "$preview_file" ]]; then
            return 0  # Ya existe, usar cache
        fi
        
        # Usar magick en lugar de convert para ImageMagick v7
        local convert_cmd="magick"
        if ! command -v magick &> /dev/null; then
            convert_cmd="convert"
        fi
        
        # Generar preview con tamaÃ±o especÃ­fico del monitor
        if [[ "$img" == *.gif ]]; then
            $convert_cmd "$img[0]" -resize "${preview_size}^" -gravity center -extent "$preview_size" -strip -quality 60 "$preview_file" 2>/dev/null || {
                local placeholder="$HOME/.cache/wal/gif-placeholder-${monitor}.png"
                if [[ ! -f "$placeholder" ]]; then
                    # Crear placeholder especÃ­fico para el tamaÃ±o del monitor
                    local width=$(echo "$preview_size" | cut -d'x' -f1)
                    local height=$(echo "$preview_size" | cut -d'x' -f2)
                    local fontsize=$((width / 12))  # Ajustar fuente segÃºn ancho
                    $convert_cmd -size "$preview_size" xc:"#2e3440" -pointsize "$fontsize" -fill white -gravity center -annotate +0+0 "GIF" "$placeholder" 2>/dev/null || touch "$placeholder"
                fi
                [[ -f "$placeholder" ]] && cp "$placeholder" "$preview_file" 2>/dev/null
            }
        else
            $convert_cmd "$img" -resize "${preview_size}^" -gravity center -extent "$preview_size" -strip -quality 60 "$preview_file" 2>/dev/null
        fi
        
        return 0
    }
    
    # Crear archivo temporal para rofi
    > "$TEMP_FILE"
    
    # Procesar imÃ¡genes para rofi
    log "ğŸš€ Generando previews adaptativas para monitor $ACTIVE_MONITOR..."
    for img in "${images[@]}"; do
        clean_name="${img%.*}"
        safe_name="$(echo "$clean_name" | sed 's/[^a-zA-Z0-9._-]/_/g')"
        preview_file="$CACHE_DIR/preview_${safe_name}_${ACTIVE_MONITOR}.png"
        
        generate_preview "$img" "$ACTIVE_MONITOR"
        
        # AÃ±adir a archivo rofi
        if [[ -f "$preview_file" ]]; then
            echo -e "$img\\0icon\\x1f$preview_file" >> "$TEMP_FILE"
        else
            echo "$img" >> "$TEMP_FILE"
        fi
    done
    
    # Verificar que tenemos entradas
    if [[ ! -s "$TEMP_FILE" ]]; then
        log "ERROR: No se pudieron procesar las imÃ¡genes"
        notify "âŒ Error: No se pudieron procesar las imÃ¡genes"
        exit 1
    fi
    
    log "ğŸ­ Mostrando selector de wallpapers adaptativo..."
    
    # Configurar rofi segÃºn el monitor
    ROFI_CONFIG=$(configure_rofi_theme "$ACTIVE_MONITOR")
    log "ğŸ¨ ConfiguraciÃ³n de Rofi: $ROFI_CONFIG"
    
    # FunciÃ³n para ejecutar rofi con manejo correcto de waybar y monitor especÃ­fico
    execute_adaptive_rofi() {
        local temp_file="$1"
        local monitor="$2"
        local config="$3"
        local result=""
        local waybar_was_running=false
        
        # Verificar si waybar estÃ¡ ejecutÃ¡ndose antes de iniciarlo
        if pgrep -x waybar > /dev/null; then
            waybar_was_running=true
            log "ğŸ“ Waybar estaba ejecutÃ¡ndose antes de rofi"
        fi
        
        log "ğŸ“± Ocultando waybar antes de rofi..."
        hide_waybar
        
        # Crear archivo limpio para rofi
        local rofi_temp_file="${temp_file}_rofi_$$"
        cat "$temp_file" > "$rofi_temp_file" 2>/dev/null
        
        log "ğŸš€ Ejecutando rofi adaptativo en monitor: $monitor"
        
        # Ejecutar rofi con configuraciÃ³n especÃ­fica del monitor
        result=$(eval "rofi -dmenu -i -p \"ğŸ–¼ï¸ Seleccionar Wallpaper\" -show-icons $config -monitor '$monitor'" < "$rofi_temp_file" 2>/dev/null || true)
        
        # Limpiar archivo temporal
        rm -f "$rofi_temp_file"
        
        # Solo restaurar Waybar si NO vamos a reiniciarlo despuÃ©s con pywal
        if [[ "$waybar_was_running" == "true" ]] && ! command -v wal > /dev/null 2>&1; then
            log "ğŸ“± Restaurando waybar despuÃ©s de rofi (sin pywal)..."
            show_waybar
        elif [[ "$waybar_was_running" == "true" ]]; then
            log "ğŸ“± No se restaura waybar ahora - se reiniciarÃ¡ despuÃ©s con pywal"
        fi
        
        echo "$result"
    }
    
    # Ejecutar rofi con configuraciÃ³n adaptativa
    selected=$(execute_adaptive_rofi "$TEMP_FILE" "$ACTIVE_MONITOR" "$ROFI_CONFIG")
    
    # Si no se seleccionÃ³ nada, salir
    if [[ -z "$selected" ]]; then
        log "â„¹ï¸ No se seleccionÃ³ ningÃºn wallpaper"
        exit 0
    fi
    
    log "âœ… Seleccionado: $selected"
    
    # Buscar el archivo correspondiente
    selected_file=""
    if [[ -f "$WALLPAPER_DIR/$selected" ]]; then
        selected_file="$WALLPAPER_DIR/$selected"
        log "ğŸ¯ Archivo encontrado: $selected_file"
    else
        for img in "${images[@]}"; do
            if [[ "${img%.*}" == "$selected" ]]; then
                selected_file="$WALLPAPER_DIR/$img"
                log "ğŸ¯ Archivo encontrado por fallback: $selected_file"
                break
            fi
        done
    fi
    
    # Verificar archivo seleccionado
    if [[ -z "$selected_file" ]] || [[ ! -f "$selected_file" ]]; then
        log "âŒ ERROR: Archivo no encontrado: $selected"
        notify "âŒ Error: Archivo no encontrado"
        exit 1
    fi
    
    log "ğŸ–¼ï¸ PASO 1: Aplicando wallpaper: $selected_file"
    
    # Aplicar wallpaper con swww
    if swww img "$selected_file" --transition-type grow --transition-pos "0.9,0.1" --transition-duration 1.5; then
        log "âœ… Wallpaper aplicado con swww"
        notify "ğŸ–¼ï¸ Wallpaper aplicado: $(basename "$selected_file")"
    else
        log "âŒ Error al aplicar wallpaper con swww"
        exit 1
    fi
    
    # Guardar wallpaper actual
    echo "$selected_file" > "$HOME/.cache/current-wallpaper"
    
    # Aplicar pywal SOLO si estÃ¡ disponible
    if command -v wal > /dev/null 2>&1; then
        log "ğŸ¨ PASO 2: Aplicando colores con pywal..."
        notify "ğŸŒˆ Generando colores con pywal..."
        
        if wal -i "$selected_file" -n -q; then
            log "âœ… Pywal aplicado exitosamente"
            
            # Esperar a que pywal genere todos los archivos
            sleep 0.5
            
            # Actualizar archivo de colores para Waybar
            log "ğŸ¨ PASO 3: Actualizando colores de Waybar..."
            if [[ -f "$HOME/.cache/wal/colors-waybar.css" ]]; then
                cp "$HOME/.cache/wal/colors-waybar.css" "$HOME/.config/waybar/colors-pywal.css"
                log "âœ… Archivo colors-waybar.css copiado"
            elif [[ -f "$HOME/.cache/wal/colors.css" ]]; then
                # Si no hay colors-waybar.css, generar desde colors.css
                cat > "$HOME/.config/waybar/colors-pywal.css" <<EOF
/* Colores generados automÃ¡ticamente por pywal */
$(grep -E '^--color[0-9]+|^--background|^--foreground|^--cursor' "$HOME/.cache/wal/colors.css" | sed 's/--/@define-color /' | sed 's/: / /g' | sed 's/;//g')
EOF
                log "âœ… Archivo colors-pywal.css generado desde colors.css"
            else
                # Generar desde colors.sh si no hay CSS
                source "$HOME/.cache/wal/colors.sh"
                cat > "$HOME/.config/waybar/colors-pywal.css" <<EOF
/* Colores generados automÃ¡ticamente por pywal */
@define-color background $background;
@define-color foreground $foreground;
@define-color cursor $cursor;
@define-color color0 $color0;
@define-color color1 $color1;
@define-color color2 $color2;
@define-color color3 $color3;
@define-color color4 $color4;
@define-color color5 $color5;
@define-color color6 $color6;
@define-color color7 $color7;
@define-color color8 $color8;
@define-color color9 $color9;
@define-color color10 $color10;
@define-color color11 $color11;
@define-color color12 $color12;
@define-color color13 $color13;
@define-color color14 $color14;
@define-color color15 $color15;
EOF
                log "âœ… Archivo colors-pywal.css generado desde colors.sh"
            fi
            
            # Recargar Hyprland config (para obtener nuevos colores)
            log "ğŸ”„ PASO 4: Recargando configuraciÃ³n de Hyprland..."
            if timeout 10s hyprctl reload > /dev/null 2>&1; then
                log "âœ… ConfiguraciÃ³n de Hyprland recargada exitosamente"
            else
                log "âŒ WARNING: No se pudo recargar Hyprland o timeout alcanzado"
            fi
            
            # Sincronizar temas de rofi con pywal
            log "ğŸ¨ PASO 5: Sincronizando temas de rofi con pywal..."
            sync_rofi_with_pywal
        else
            log "âŒ Error: Pywal fallÃ³"
            notify "âš ï¸ Error en pywal - wallpaper aplicado parcialmente"
        fi
    else
        log "â„¹ï¸ Pywal no disponible, solo se aplicÃ³ el wallpaper"
    fi
fi

# Mostrar configuraciÃ³n actual detectada
log "ğŸ¯ Mostrando configuraciÃ³n actual de SDDM..."
~/.local/bin/sddm-auto-sync-local --show-config

echo ""
log "ğŸ”„ PASO FINAL: Aplicando sincronizaciÃ³n completa SDDM..."
echo "ğŸ”„ Aplicando sincronizaciÃ³n completa SDDM..."

# Ejecutar la sincronizaciÃ³n completa de SDDM (wallpaper + monitores + cursor)
if ~/.local/bin/sddm-auto-sync-local; then
    log "âœ… SDDM sincronizado exitosamente"
else
    log "âŒ Error en la sincronizaciÃ³n de SDDM"
fi

# Reiniciar Waybar con los nuevos colores si pywal estÃ¡ disponible
if command -v wal > /dev/null 2>&1 && [[ "$DIRECT_FILE_PROCESSING" != "true" ]]; then
    log "ğŸ“± PASO FINAL: Reiniciando Waybar con nuevos colores..."
    
    # Verificar que el archivo de colores existe antes de reiniciar waybar
    if [[ -f "$HOME/.config/waybar/colors-pywal.css" ]]; then
        log "âœ… Archivo de colores de waybar confirmado"
    else
        log "âŒ WARNING: Archivo de colores de waybar no encontrado"
    fi
    
    # Cerrar waybar existente de forma mÃ¡s robusta
    waybar_count=$(pgrep -x waybar | wc -l)
    log "ğŸ” Instancias de waybar detectadas: $waybar_count"
    
    if [[ $waybar_count -gt 0 ]]; then
        log "ğŸš« Cerrando todas las instancias de waybar..."
        # MÃ©todo progresivo: TERM primero, luego KILL
        pkill -TERM waybar 2>/dev/null || true
        sleep 0.2
        pkill -KILL waybar 2>/dev/null || true
        sleep 0.1
    fi
    
    # Iniciar waybar inmediatamente
    log "ğŸš€ Iniciando nueva instancia de waybar con colores actualizados..."
    nohup waybar > /dev/null 2>&1 &
    waybar_pid=$!
    
    # Esperar un poco mÃ¡s para que waybar cargue los colores
    sleep 1.0
    
    if pgrep -x waybar > /dev/null; then
        log "âœ… Waybar reiniciado exitosamente con nuevos colores (PID: $waybar_pid)"
        
        # VerificaciÃ³n adicional de que waybar cargÃ³ correctamente
        sleep 0.5
        if hyprctl workspaces | grep -q "workspace ID"; then
            log "âœ… MÃ³dulo de workspaces funcionando correctamente"
        else
            log "âš ï¸ Advertencia: No se pudo verificar el estado de workspaces"
        fi
    else
        log "âŒ Error: Waybar no se iniciÃ³ correctamente"
        notify "âš ï¸ Error: Waybar no se iniciÃ³ despuÃ©s de aplicar colores"
    fi
    
    # Configurar temas GTK
    log "ğŸ¨ Configurando temas GTK..."
    gsettings set org.gnome.desktop.interface gtk-theme "PywalSync-Mono" 2>/dev/null || true
    gsettings set org.gnome.desktop.interface icon-theme "Tela-circle-black-dark" 2>/dev/null || true
    export GTK_THEME="PywalSync-Mono"
    log "âœ… Temas GTK configurados a PywalSync-Mono"
    
    # Reiniciar nm-applet
    log "ğŸŒ Reiniciando nm-applet..."
    if pgrep -x nm-applet > /dev/null; then
        pkill -9 nm-applet 2>/dev/null || true
        sleep 0.2
    fi
    nm-applet --indicator > /dev/null 2>&1 &
    sleep 0.2
    if pgrep -x nm-applet > /dev/null; then
        log "âœ… nm-applet reiniciado exitosamente"
    fi
fi

# VerificaciÃ³n final de Waybar
if ! pgrep -x waybar > /dev/null; then
    log "âŒ CRÃTICO: Waybar no estÃ¡ ejecutÃ¡ndose al finalizar. Iniciando respaldo..."
    notify "ğŸ”§ Iniciando waybar de respaldo..."
    
    nohup waybar > /dev/null 2>&1 &
    sleep 0.5
    
    if pgrep -x waybar > /dev/null; then
        log "âœ… RESPALDO EXITOSO: Waybar iniciado correctamente"
        notify "âœ… Waybar restaurado exitosamente"
    else
        log "âŒ FALLO CRÃTICO: No se pudo iniciar waybar"
        notify "âŒ Error crÃ­tico: No se pudo iniciar waybar"
    fi
else
    log "âœ… VERIFICACIÃ“N EXITOSA: Waybar estÃ¡ ejecutÃ¡ndose correctamente"
fi

echo ""
echo "âœ… SDDM completamente sincronizado:"
echo "   ğŸ–¼ï¸ Wallpaper: Desde swww (GIF â†’ JPG automÃ¡tico)"
echo "   ğŸ–¥ï¸ Monitores: Compatible con nwg-displays"
echo "   ğŸ–±ï¸ Cursor: Bibata-Modern-Ice"
echo "   ğŸ¨ Colores: Sincronizados con pywal"
echo "   ğŸ“± Waybar: Reiniciado con nuevos colores"
echo "   ğŸŒ Aplicaciones: nm-applet sincronizado"
echo ""
echo "ğŸ’¡ Para aplicar cambios en SDDM: sddm-auto-sync-local --restart"

log "ğŸ‰ === CAMBIO DE WALLPAPER Y SINCRONIZACIÃ“N SDDM COMPLETADO ==="
if [[ -n "${selected_file:-}" ]]; then
    log "ğŸ“¸ Wallpaper: $(basename "$selected_file")"
fi
log "ğŸ–¥ï¸ Monitor: ${ACTIVE_MONITOR:-N/A}"
log "ğŸ¨ Sistema completamente sincronizado"

notify "ğŸ‰ Â¡Wallpaper y SDDM completamente sincronizados!"

exit 0

