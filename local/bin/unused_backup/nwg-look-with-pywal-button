#!/usr/bin/env python3

"""
nwg-look con bot√≥n de pywal-gtk4 integrado
Esta aplicaci√≥n crea una ventana que contiene nwg-look embebido 
y un bot√≥n adicional para ejecutar pywal-gtk4 generate
"""

import sys
import os
import subprocess
import threading
import gi

gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib, Gio

class NwgLookPywalApp(Gtk.Window):
    def __init__(self):
        super().__init__(title="GTK Settings with pywal-gtk4")
        self.set_default_size(800, 600)
        self.set_border_width(10)
        
        # Variables
        self.pywal_process = None
        self.nwg_process = None
        
        # Crear layout principal
        main_box = Gtk.VBox(spacing=10)
        self.add(main_box)
        
        # Header con t√≠tulo e informaci√≥n
        header = self.create_header()
        main_box.pack_start(header, False, False, 0)
        
        # √Årea principal con botones
        button_area = self.create_button_area()
        main_box.pack_start(button_area, False, False, 0)
        
        # √Årea de logs/estado
        self.log_area = self.create_log_area()
        main_box.pack_start(self.log_area, True, True, 0)
        
        # Footer con botones de acci√≥n
        footer = self.create_footer()
        main_box.pack_start(footer, False, False, 0)
        
        # Conectar se√±ales
        self.connect("delete-event", self.on_delete_event)
        
        # Mensaje inicial
        self.log_message("üé® GTK Settings con integraci√≥n pywal-gtk4 iniciado")
        self.log_message("üí° Usa los botones para configurar temas y aplicar pywal-gtk4")

    def create_header(self):
        """Crear header con t√≠tulo e informaci√≥n"""
        header_box = Gtk.HBox(spacing=10)
        
        # Icono
        icon = Gtk.Image()
        icon.set_from_icon_name("preferences-desktop-theme", Gtk.IconSize.LARGE_TOOLBAR)
        header_box.pack_start(icon, False, False, 0)
        
        # Informaci√≥n
        info_box = Gtk.VBox()
        
        title_label = Gtk.Label()
        title_label.set_markup("<b>GTK Settings con pywal-gtk4</b>")
        title_label.set_halign(Gtk.Align.START)
        info_box.pack_start(title_label, False, False, 0)
        
        desc_label = Gtk.Label("Configuraci√≥n de temas GTK con integraci√≥n autom√°tica de pywal")
        desc_label.set_halign(Gtk.Align.START)
        desc_label.get_style_context().add_class("dim-label")
        info_box.pack_start(desc_label, False, False, 0)
        
        header_box.pack_start(info_box, True, True, 0)
        
        return header_box

    def create_button_area(self):
        """Crear √°rea de botones principales"""
        button_box = Gtk.HBox(spacing=10, homogeneous=True)
        
        # Bot√≥n para abrir nwg-look
        nwg_button = Gtk.Button()
        nwg_button.set_label("üéõÔ∏è Configurar Temas (nwg-look)")
        nwg_button.connect("clicked", self.on_open_nwg_look)
        button_box.pack_start(nwg_button, True, True, 0)
        
        # Bot√≥n para ejecutar pywal-gtk4
        pywal_button = Gtk.Button()
        pywal_button.set_label("üé® Generar Tema pywal-gtk4")
        pywal_button.connect("clicked", self.on_generate_pywal)
        pywal_button.get_style_context().add_class("suggested-action")
        button_box.pack_start(pywal_button, True, True, 0)
        
        # Bot√≥n combinado
        combo_button = Gtk.Button()
        combo_button.set_label("‚ö° Configurar + Generar")
        combo_button.connect("clicked", self.on_combo_action)
        combo_button.get_style_context().add_class("destructive-action")
        button_box.pack_start(combo_button, True, True, 0)
        
        return button_box

    def create_log_area(self):
        """Crear √°rea de logs y estado"""
        log_frame = Gtk.Frame(label="Estado y Logs")
        
        scrolled = Gtk.ScrolledWindow()
        scrolled.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        scrolled.set_min_content_height(200)
        
        self.text_view = Gtk.TextView()
        self.text_view.set_editable(False)
        self.text_view.set_cursor_visible(False)
        self.text_view.set_wrap_mode(Gtk.WrapMode.WORD)
        
        # Buffer para el texto
        self.text_buffer = self.text_view.get_buffer()
        
        scrolled.add(self.text_view)
        log_frame.add(scrolled)
        
        return log_frame

    def create_footer(self):
        """Crear footer con botones de acci√≥n"""
        footer_box = Gtk.HBox(spacing=10)
        
        # Bot√≥n de estado
        status_button = Gtk.Button(label="üìä Ver Estado")
        status_button.connect("clicked", self.on_show_status)
        footer_box.pack_start(status_button, False, False, 0)
        
        # Separador
        footer_box.pack_start(Gtk.Label(), True, True, 0)
        
        # Bot√≥n de limpiar logs
        clear_button = Gtk.Button(label="üßπ Limpiar")
        clear_button.connect("clicked", self.on_clear_logs)
        footer_box.pack_start(clear_button, False, False, 0)
        
        # Bot√≥n de cerrar
        close_button = Gtk.Button(label="‚ùå Cerrar")
        close_button.connect("clicked", self.on_close)
        footer_box.pack_start(close_button, False, False, 0)
        
        return footer_box

    def log_message(self, message):
        """Agregar mensaje al √°rea de logs"""
        def add_text():
            end_iter = self.text_buffer.get_end_iter()
            timestamp = GLib.DateTime.new_now_local().format("%H:%M:%S")
            self.text_buffer.insert(end_iter, f"[{timestamp}] {message}\n")
            
            # Scroll al final
            mark = self.text_buffer.get_insert()
            self.text_view.scroll_mark_onscreen(mark)
            
        GLib.idle_add(add_text)

    def run_command_async(self, command, success_msg, error_msg):
        """Ejecutar comando de forma as√≠ncrona"""
        def run():
            try:
                self.log_message(f"üöÄ Ejecutando: {' '.join(command)}")
                result = subprocess.run(command, capture_output=True, text=True, check=True)
                
                if result.stdout:
                    GLib.idle_add(lambda: self.log_message(f"üì§ Salida: {result.stdout.strip()}"))
                
                GLib.idle_add(lambda: self.log_message(f"‚úÖ {success_msg}"))
                
            except subprocess.CalledProcessError as e:
                error_text = f"{error_msg}: {e.stderr.strip() if e.stderr else str(e)}"
                GLib.idle_add(lambda: self.log_message(f"‚ùå {error_text}"))
            except Exception as e:
                GLib.idle_add(lambda: self.log_message(f"‚ùå Error inesperado: {str(e)}"))
        
        thread = threading.Thread(target=run)
        thread.daemon = True
        thread.start()

    def on_open_nwg_look(self, button):
        """Abrir nwg-look"""
        button.set_sensitive(False)
        self.log_message("üéõÔ∏è Abriendo nwg-look...")
        
        def run_nwg():
            try:
                subprocess.run(["nwg-look"], check=True)
                GLib.idle_add(lambda: self.log_message("‚úÖ nwg-look cerrado"))
            except Exception as e:
                GLib.idle_add(lambda: self.log_message(f"‚ùå Error ejecutando nwg-look: {str(e)}"))
            finally:
                GLib.idle_add(lambda: button.set_sensitive(True))
        
        thread = threading.Thread(target=run_nwg)
        thread.daemon = True
        thread.start()

    def on_generate_pywal(self, button):
        """Generar tema pywal-gtk4"""
        pywal_cmd = [os.path.expanduser("~/.local/bin/pywal-gtk4"), "generate"]
        self.run_command_async(pywal_cmd, "Tema pywal-gtk4 generado exitosamente", "Error generando tema pywal-gtk4")

    def on_combo_action(self, button):
        """Acci√≥n combinada: configurar + generar"""
        button.set_sensitive(False)
        self.log_message("‚ö° Iniciando acci√≥n combinada...")
        
        def run_combo():
            try:
                # Primero ejecutar nwg-look
                self.log_message("üéõÔ∏è Paso 1: Abriendo nwg-look...")
                subprocess.run(["nwg-look"], check=True)
                
                # Luego ejecutar pywal-gtk4
                GLib.idle_add(lambda: self.log_message("üé® Paso 2: Generando tema pywal-gtk4..."))
                pywal_cmd = [os.path.expanduser("~/.local/bin/pywal-gtk4"), "generate"]
                result = subprocess.run(pywal_cmd, capture_output=True, text=True, check=True)
                
                GLib.idle_add(lambda: self.log_message("‚úÖ Acci√≥n combinada completada exitosamente"))
                
            except Exception as e:
                GLib.idle_add(lambda: self.log_message(f"‚ùå Error en acci√≥n combinada: {str(e)}"))
            finally:
                GLib.idle_add(lambda: button.set_sensitive(True))
        
        thread = threading.Thread(target=run_combo)
        thread.daemon = True
        thread.start()

    def on_show_status(self, button):
        """Mostrar estado del sistema"""
        self.log_message("üìä Verificando estado del sistema...")
        
        # Verificar pywal-gtk4
        pywal_path = os.path.expanduser("~/.local/bin/pywal-gtk4")
        if os.path.exists(pywal_path) and os.access(pywal_path, os.X_OK):
            self.log_message("‚úÖ pywal-gtk4 disponible")
        else:
            self.log_message("‚ùå pywal-gtk4 no encontrado o no ejecutable")
        
        # Verificar nwg-look
        try:
            subprocess.run(["which", "nwg-look"], check=True, capture_output=True)
            self.log_message("‚úÖ nwg-look disponible")
        except:
            self.log_message("‚ùå nwg-look no encontrado")
        
        # Mostrar colores actuales de pywal
        self.run_command_async([pywal_path, "colors"], "Colores pywal mostrados", "Error obteniendo colores pywal")

    def on_clear_logs(self, button):
        """Limpiar √°rea de logs"""
        self.text_buffer.set_text("")
        self.log_message("üßπ Logs limpiados")

    def on_close(self, button):
        """Cerrar aplicaci√≥n"""
        Gtk.main_quit()

    def on_delete_event(self, widget, event):
        """Manejar cierre de ventana"""
        Gtk.main_quit()
        return False

def main():
    # Verificar dependencias b√°sicas
    if not os.path.exists(os.path.expanduser("~/.local/bin/pywal-gtk4")):
        print("‚ùå Error: pywal-gtk4 no encontrado en ~/.local/bin/pywal-gtk4")
        sys.exit(1)
    
    try:
        subprocess.run(["which", "nwg-look"], check=True, capture_output=True)
    except:
        print("‚ùå Error: nwg-look no encontrado")
        sys.exit(1)
    
    # Crear y ejecutar aplicaci√≥n
    app = NwgLookPywalApp()
    app.show_all()
    
    try:
        Gtk.main()
    except KeyboardInterrupt:
        print("\nüõë Interrumpido por usuario")
        sys.exit(0)

if __name__ == "__main__":
    main()
