#!/bin/bash

# Script optimizado para cambiar wallpaper SIN perder workspaces de waybar
# M√©todo mejorado que evita problemas con hyprland/workspaces
# Ejecutado por: Super + Shift + W en Hyprland

set -euo pipefail

WALLPAPER_DIR="$HOME/Pictures/Wallpapers"
CACHE_DIR="$HOME/.cache/wallpaper-previews"
TEMP_FILE="/tmp/rofi_wallpaper_fixed_$$"
LOG_FILE="$HOME/.cache/wallpaper-change-fixed.log"
LOCK_FILE="/tmp/wallpaper-change-fixed.lock"

# Funci√≥n de logging con timestamp
log() {
    local message="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    # Usar flock para evitar conflictos de escritura cuando rofi est√° leyendo archivos
    echo "$message" >> "$LOG_FILE"
}

# Funci√≥n de notificaci√≥n
notify() {
    notify-send "üé® Wallpaper Change" "$1" -t 3000 2>/dev/null || true
}

# Verificar si ya est√° ejecut√°ndose
if [[ -f "$LOCK_FILE" ]]; then
    lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
        log "‚è≥ Cambio de wallpaper ya en progreso (PID: $lock_pid)"
        exit 0
    fi
fi

# Crear lock
echo $$ > "$LOCK_FILE"

# Funci√≥n de cleanup
cleanup() {
    rm -f "$TEMP_FILE"* 2>/dev/null || true
    rm -f "$LOCK_FILE"
    
    # OPTIMIZACI√ìN: Solo mostrar Waybar si se cancel√≥ antes de completar el proceso
    # Y si estaba ejecut√°ndose originalmente Y si no fue reiniciado ya por el proceso principal
    if [[ "${ROFI_COMPLETED:-}" != "true" ]] && [[ "${ORIGINAL_WAYBAR_STATE:-}" == "running" ]] && [[ "${WAYBAR_ALREADY_RESTARTED:-}" != "true" ]]; then
        log "üì± Cleanup: Restaurando Waybar debido a cancelaci√≥n temprana..."
        show_waybar
    elif [[ "${ROFI_COMPLETED:-}" != "true" ]] && [[ "${WAYBAR_ALREADY_RESTARTED:-}" == "true" ]]; then
        log "üì± Cleanup: Waybar ya fue reiniciado, no se toca"
    elif [[ "${ROFI_COMPLETED:-}" != "true" ]]; then
        log "üì± Cleanup: Waybar no estaba ejecut√°ndose originalmente, no se restaura"
    fi
    
    # Registrar variables de control para debug
    log "‚ÑπÔ∏è Estado final de variables de control:"
    log "   - WAYBAR_ALREADY_RESTARTED: ${WAYBAR_ALREADY_RESTARTED:-false}"
    log "   - NM_APPLET_ALREADY_RESTARTED: ${NM_APPLET_ALREADY_RESTARTED:-false}"
    log "   - ROFI_COMPLETED: ${ROFI_COMPLETED:-false}"
}
trap cleanup EXIT INT TERM

# Funci√≥n para ocultar Waybar (m√©todo optimizado para velocidad)
hide_waybar() {
    log "üì± Ocultando Waybar..."
    
    # M√©todo r√°pido: matar directamente
    if pgrep -x waybar > /dev/null; then
        log "üõë Deteniendo waybar..."
        pkill -KILL waybar 2>/dev/null
        sleep 0.1  # Reducido de 0.5 a 0.1
        
        if ! pgrep -x waybar > /dev/null; then
            log "‚úÖ Waybar detenido r√°pidamente"
            return 0
        fi
    else
        log "‚ÑπÔ∏è Waybar ya estaba detenido"
        return 0
    fi
    
    log "‚ö†Ô∏è No se pudo ocultar waybar completamente"
}

# Funci√≥n para mostrar Waybar (m√©todo optimizado para velocidad)
show_waybar() {
    log "üì± Mostrando Waybar..."
    
    # Verificar si waybar est√° ejecut√°ndose
    if ! pgrep -x waybar > /dev/null; then
        log "üîÑ Waybar no est√° ejecut√°ndose, iniciando..."
        # Iniciar waybar en background con nohup
        nohup waybar >/dev/null 2>&1 &
        waybar_pid=$!
        
        # Esperar m√≠nimo para que inicie
        sleep 0.3  # Reducido de 1.5 a 0.3
        
        if pgrep -x waybar > /dev/null; then
            log "‚úÖ Waybar iniciado r√°pidamente (PID: $waybar_pid)"
        else
            log "‚ö†Ô∏è Waybar tardando en iniciar, continuando..."
            # No esperamos m√°s, continuamos
        fi
    else
        log "‚ÑπÔ∏è Waybar ya estaba ejecut√°ndose"
    fi
}

# Determinar estado original de waybar para manejo correcto en caso de cancelaci√≥n
if pgrep -x waybar > /dev/null; then
    ORIGINAL_WAYBAR_STATE="running"
    log "üìù Estado inicial: Waybar est√° ejecut√°ndose"
else
    ORIGINAL_WAYBAR_STATE="stopped"
    log "üìù Estado inicial: Waybar no est√° ejecut√°ndose"
fi

# Inicializar variables de control para evitar reinicios dobles
WAYBAR_ALREADY_RESTARTED="false"
NM_APPLET_ALREADY_RESTARTED="false"

log "üöÄ === INICIANDO CAMBIO DE WALLPAPER (M√âTODO FIXED) ==="
notify "Iniciando cambio de wallpaper..."

# Verificar directorio de wallpapers
if [[ ! -d "$WALLPAPER_DIR" ]]; then
    log "ERROR: Directorio $WALLPAPER_DIR no encontrado"
    notify "‚ùå Error: Directorio de wallpapers no encontrado"
    exit 1
fi

# Verificar swww
if ! command -v swww &>/dev/null; then
    log "ERROR: swww no est√° instalado"
    notify "‚ùå Error: swww no est√° instalado"
    exit 1
fi

# Verificar e iniciar swww-daemon si es necesario
if ! pgrep -x "swww-daemon" > /dev/null; then
    log "üöÄ Iniciando swww-daemon..."
    swww-daemon --format xrgb &
    # NO sleep - continuar inmediatamente
fi

# Crear directorios necesarios
mkdir -p "$CACHE_DIR"

# Buscar im√°genes
log "üîç Buscando im√°genes en $WALLPAPER_DIR"
cd "$WALLPAPER_DIR" || { log "ERROR: No se pudo acceder a $WALLPAPER_DIR"; exit 1; }

mapfile -t images < <(find . -maxdepth 1 -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.gif" -o -iname "*.webp" -o -iname "*.bmp" \) | sed 's|^./||' | sort)

if [[ ${#images[@]} -eq 0 ]]; then
    log "ERROR: No se encontraron im√°genes"
    notify "‚ùå Error: No se encontraron im√°genes"
    exit 1
fi

log "üìÅ Encontradas ${#images[@]} im√°genes"

# Crear archivo temporal para rofi
> "$TEMP_FILE"
# Funci√≥n para generar preview R√ÅPIDA (cache simple)
generate_preview() {
    local img="$1"
    local clean_name="${img%.*}"
    local safe_name="$(echo "$clean_name" | sed 's/[^a-zA-Z0-9._-]/_/g')"
    local preview_file="$CACHE_DIR/preview_${safe_name}.png"
    
    # Cache simple: Solo verificar si existe
    if [[ -f "$preview_file" ]]; then
        return 0  # Ya existe, usar cache
    fi
    
    # Generar preview
    if [[ "$img" == *.gif ]]; then
        # GIF: usar placeholder
        local placeholder="$HOME/.cache/wal/gif-placeholder.png"
        if [[ ! -f "$placeholder" ]]; then
            convert -size 150x100 xc:"#2e3440" -pointsize 12 -fill white -gravity center -annotate +0+0 "GIF" "$placeholder" 2>/dev/null || touch "$placeholder"
        fi
        [[ -f "$placeholder" ]] && cp "$placeholder" "$preview_file" 2>/dev/null
    else
        # Imagen est√°tica: conversi√≥n r√°pida
        convert "$img" -resize "150x100^" -gravity center -extent "150x100" -strip -quality 60 "$preview_file" 2>/dev/null
    fi
    
    return 0
}

# Procesar im√°genes en paralelo para m√°xima velocidad
log "üöÄ Generando previews en paralelo..."
pids=()
max_jobs=4  # N√∫mero de trabajos paralelos

# Funci√≥n para procesar una imagen individual
process_image() {
    local img="$1"
    [[ ! -f "$img" ]] && return
    
    if generate_preview "$img"; then
        local clean_name="${img%.*}"
        local safe_name="$(echo "$clean_name" | sed 's/[^a-zA-Z0-9._-]/_/g')"
        local preview_file="$CACHE_DIR/preview_${safe_name}.png"
        
        # Agregar entrada a archivo temporal individual
        local temp_entry="$TEMP_FILE.$(basename "$img")" 
        if [[ -f "$preview_file" ]]; then
            echo -e "$img\\0icon\\x1f$preview_file" > "$temp_entry"
        else
            echo "$img" > "$temp_entry"
        fi
    fi
}

# Procesar im√°genes SILENCIOSAMENTE para m√°xima velocidad
for img in "${images[@]}"; do
    clean_name="${img%.*}"
    safe_name="$(echo "$clean_name" | sed 's/[^a-zA-Z0-9._-]/_/g')"
    preview_file="$CACHE_DIR/preview_${safe_name}.png"
    
    # Generar preview sin logs detallados
    generate_preview "$img"
    
    # A√±adir a archivo rofi
    if [[ -f "$preview_file" ]]; then
        echo -e "$img\\0icon\\x1f$preview_file" >> "$TEMP_FILE"
    else
        echo "$img" >> "$TEMP_FILE"
    fi
done

log "‚úÖ Procesamiento paralelo completado"

# Verificar que tenemos entradas
if [[ ! -s "$TEMP_FILE" ]]; then
    log "ERROR: No se pudieron procesar las im√°genes"
    notify "‚ùå Error: No se pudieron procesar las im√°genes"
    exit 1
fi

log "üé≠ Mostrando selector de wallpapers..."

# ===== M√âTODO CONSISTENTE PARA ROFI + WAYBAR =====
log "üì± Configurando manejo de waybar para rofi..."

# Funci√≥n para ejecutar rofi con manejo correcto de waybar
execute_rofi_with_waybar() {
    local temp_file="$1"
    local result=""
    local waybar_was_running=false
    
    # Verificar si waybar est√° ejecut√°ndose antes de iniciarlo
    if pgrep -x waybar > /dev/null; then
        waybar_was_running=true
        log "üìù Waybar estaba ejecut√°ndose antes de rofi"
    else
        log "üìù Waybar no estaba ejecut√°ndose antes de rofi"
    fi
    
    log "üì± Ocultando waybar antes de rofi..."
    hide_waybar
    
    # Verificaci√≥n r√°pida
    sleep 0.1  # Reducido de 0.5 a 0.1
    if pgrep -x waybar > /dev/null; then
        log "‚ö†Ô∏è Waybar sigue ejecut√°ndose, forzando cierre..."
        pkill -KILL waybar 2>/dev/null
        sleep 0.1  # Reducido de 0.3 a 0.1
    fi
    
    log "üöÄ Ejecutando rofi..."
    # Crear una copia temporal del archivo para evitar problemas con logs concurrentes
    local rofi_temp_file="${temp_file}_rofi"
    cp "$temp_file" "$rofi_temp_file"
    
    result=$(rofi -dmenu -i \
        -p "üñºÔ∏è Seleccionar Wallpaper" \
        -show-icons \
        -theme "$HOME/Downloads/wallpaper-select.rasi" \
        < "$rofi_temp_file" || true)
    
    # Limpiar archivo temporal
    rm -f "$rofi_temp_file"
    
    # IMPORTANTE: Solo restaurar Waybar si NO vamos a reiniciarlo despu√©s
    # Si pywal est√° disponible, el reinicio se har√° en el paso principal
    if [[ "$waybar_was_running" == "true" ]] && ! command -v wal > /dev/null 2>&1; then
        log "üì± Restaurando waybar despu√©s de rofi (sin pywal)..."
        show_waybar
    elif [[ "$waybar_was_running" == "true" ]]; then
        log "üì± No se restaura waybar ahora - se reiniciar√° despu√©s con pywal"
    else
        log "‚ÑπÔ∏è No se restaura waybar porque no estaba ejecut√°ndose antes"
    fi
    
    echo "$result"
}

# Ejecutar rofi con manejo mejorado
selected=$(execute_rofi_with_waybar "$TEMP_FILE")

# Marcar que Rofi se complet√≥ correctamente
ROFI_COMPLETED="true"

# Si no se seleccion√≥ nada, salir
if [[ -z "$selected" ]]; then
    log "‚ÑπÔ∏è No se seleccion√≥ ning√∫n wallpaper"
    exit 0
fi

log "‚úÖ Seleccionado: $selected"

# ARREGLO: Si la selecci√≥n contiene texto de log (detectar por formato de timestamp), extraer solo el nombre del archivo
if [[ "$selected" =~ \[20[0-9][0-9]-[0-9][0-9]-[0-9][0-9] ]]; then
    log "‚ö†Ô∏è Detectado texto de log en selecci√≥n, extrayendo nombre del archivo..."
    # Extraer la √∫ltima l√≠nea que contenga un nombre de archivo v√°lido
    selected=$(echo "$selected" | grep -E '\.(jpg|jpeg|png|gif|webp|bmp)$' | tail -1 | tr -d '\n')
    log "üîß Archivo extra√≠do del log: '$selected'"
fi

# Buscar el archivo correspondiente - ahora seleccionamos el nombre completo
selected_file=""

# Primero intentar b√∫squeda directa (nombre completo del archivo)
if [[ -f "$WALLPAPER_DIR/$selected" ]]; then
    selected_file="$WALLPAPER_DIR/$selected"
    log "üéØ Archivo encontrado directamente: $selected_file"
else
    # Fallback: buscar por nombre sin extensi√≥n (compatibilidad)
    for img in "${images[@]}"; do
        if [[ "${img%.*}" == "$selected" ]]; then
            selected_file="$WALLPAPER_DIR/$img"
            log "üéØ Archivo encontrado por fallback: $selected_file"
            break
        fi
    done
fi

# Verificar archivo seleccionado
if [[ -z "$selected_file" ]] || [[ ! -f "$selected_file" ]]; then
    log "‚ùå ERROR: Archivo no encontrado: $selected"
    log "üîç Debug info:"
    log "   - Selecci√≥n: '$selected'"
    log "   - Directorio: '$WALLPAPER_DIR'"
    log "   - Archivos disponibles:"
    for img in "${images[@]}"; do
        log "     * '$img'"
    done
    notify "‚ùå Error: Archivo no encontrado"
    exit 1
fi

# ===== APLICACI√ìN MEJORADA DEL WALLPAPER =====

log "üñºÔ∏è PASO 1: Aplicando wallpaper: $selected_file"

# 1. Aplicar wallpaper con swww
if swww img "$selected_file" --transition-type grow --transition-pos "0.9,0.1" --transition-duration 1.5; then
    log "‚úÖ Wallpaper aplicado con swww"
    notify "üñºÔ∏è Wallpaper aplicado: $(basename "$selected_file")"
else
    log "‚ùå Error al aplicar wallpaper con swww"
    exit 1
fi

# 2. Los monitores se configurar√°n autom√°ticamente al recargar Hyprland config
log "üñ•Ô∏è PASO 1.5: Los monitores se configurar√°n con hyprctl reload..."

# 3. Guardar wallpaper actual
echo "$selected_file" > "$HOME/.cache/current-wallpaper"

# 4. Aplicar pywal SOLO si est√° disponible
if command -v wal > /dev/null 2>&1; then
    log "üé® PASO 2: Aplicando colores con pywal..."
    notify "üåà Generando colores con pywal..."
    
    if wal -i "$selected_file" -n -q; then
        log "‚úÖ Pywal aplicado exitosamente"
        
        # Esperar a que pywal genere todos los archivos - reducido
        sleep 0.5
        
        # 5. Actualizar archivo de colores para Waybar
        log "üé® PASO 3: Actualizando colores de Waybar..."
        if [[ -f "$HOME/.cache/wal/colors-waybar.css" ]]; then
            cp "$HOME/.cache/wal/colors-waybar.css" "$HOME/.config/waybar/colors-pywal.css"
            log "‚úÖ Archivo colors-waybar.css copiado"
        elif [[ -f "$HOME/.cache/wal/colors.css" ]]; then
            # Si no hay colors-waybar.css, generar desde colors.css
            cat > "$HOME/.config/waybar/colors-pywal.css" <<EOF
/* Colores generados autom√°ticamente por pywal */
$(grep -E '^--color[0-9]+|^--background|^--foreground|^--cursor' "$HOME/.cache/wal/colors.css" | sed 's/--/@define-color /' | sed 's/: / /g' | sed 's/;//g')
EOF
            log "‚úÖ Archivo colors-pywal.css generado desde colors.css"
        else
            # Generar desde colors.sh si no hay CSS
            source "$HOME/.cache/wal/colors.sh"
            cat > "$HOME/.config/waybar/colors-pywal.css" <<EOF
/* Colores generados autom√°ticamente por pywal */
@define-color background $background;
@define-color foreground $foreground;
@define-color cursor $cursor;
@define-color color0 $color0;
@define-color color1 $color1;
@define-color color2 $color2;
@define-color color3 $color3;
@define-color color4 $color4;
@define-color color5 $color5;
@define-color color6 $color6;
@define-color color7 $color7;
@define-color color8 $color8;
@define-color color9 $color9;
@define-color color10 $color10;
@define-color color11 $color11;
@define-color color12 $color12;
@define-color color13 $color13;
@define-color color14 $color14;
@define-color color15 $color15;
EOF
            log "‚úÖ Archivo colors-pywal.css generado desde colors.sh"
        fi
        
        # 5. Recargar Hyprland config (para obtener nuevos colores)
        log "üîÑ PASO 4: Recargando configuraci√≥n de Hyprland..."
        hyprctl reload > /dev/null 2>&1 || log "WARNING: No se pudo recargar Hyprland"
        
        # 6. M√âTODO MEJORADO: Reiniciar Waybar UNA SOLA VEZ
        log "üì± PASO 5: Reiniciando Waybar una sola vez..."
        
        # Variable de control para evitar reinicio doble
        if [[ "${WAYBAR_ALREADY_RESTARTED:-}" == "true" ]]; then
            log "‚ÑπÔ∏è Waybar ya fue reiniciado anteriormente, omitiendo paso..."
        else
            # Marcar waybar como ya reiniciado
            WAYBAR_ALREADY_RESTARTED="true"
            
            # Verificar si waybar est√° ejecut√°ndose
            waybar_count=$(pgrep -x waybar | wc -l)
            log "üîç Instancias de waybar detectadas: $waybar_count"
            
            if [[ $waybar_count -gt 0 ]]; then
                log "üõë Cerrando todas las instancias de waybar..."
                # Cerrar waybar limpiamente
                pkill -TERM waybar 2>/dev/null || true
                
                # M√©todo ultra-r√°pido: matar inmediatamente y reiniciar
                log "üõë Cerrando todas las instancias de waybar r√°pido..."
                pkill -KILL waybar 2>/dev/null || true
                sleep 0.1  # Solo esperar 0.1 segundos
            fi
            
            # Iniciar waybar inmediatamente
            log "üöÄ Iniciando nueva instancia de waybar..."
            nohup waybar > /dev/null 2>&1 &
            waybar_pid=$!
            
            # Esperar m√≠nimo para que inicie - reducido dr√°sticamente
            sleep 0.8  # Reducido de 3 a 0.8 segundos
            
            if pgrep -x waybar > /dev/null; then
                log "‚úÖ Waybar reiniciado exitosamente (PID: $waybar_pid)"
                
                # Verificaci√≥n r√°pida de workspaces - sin sleep adicional
                log "üîç Verificando m√≥dulo de workspaces..."
                if hyprctl workspaces | grep -q "workspace ID"; then
                    log "‚úÖ M√≥dulo de workspaces funcionando correctamente"
                else
                    log "‚ö†Ô∏è Advertencia: No se pudo verificar el estado de workspaces"
                fi
            else
                log "‚ùå Error: Waybar no se inici√≥ correctamente"
                notify "‚ö†Ô∏è Error: Waybar no se inici√≥ despu√©s de aplicar colores"
            fi
        fi
        
        # 7. Configurar temas GTK (despu√©s de pywal) - sin delay
        log "üé® PASO 6: Configurando temas GTK..."
        
        # Aplicar tema Arc-Dark
        if gsettings set org.gnome.desktop.interface gtk-theme "Arc-Dark" 2>/dev/null; then
            log "‚úÖ Tema GTK Arc-Dark aplicado"
        else
            log "‚ö†Ô∏è No se pudo aplicar Arc-Dark, usando tema predeterminado"
        fi
        
        # Aplicar iconos Tela circle black
        if gsettings set org.gnome.desktop.interface icon-theme "Tela-circle-black-dark" 2>/dev/null; then
            log "‚úÖ Tema de iconos Tela-circle-black-dark aplicado"
        else
            log "‚ö†Ô∏è No se pudo aplicar Tela-circle-black-dark, usando tema predeterminado"
        fi
        
        # Exportar variables de entorno
        export GTK_THEME="Arc-Dark"
        
        log "‚úÖ Temas GTK configurados correctamente"
        
        # 8. OPTIMIZADO: Reinicio UNA SOLA VEZ de nm-applet
        log "üåê PASO 7: Reinicio √∫nico de nm-applet..."
        
        # Variable de control para evitar reinicio doble
        if [[ "${NM_APPLET_ALREADY_RESTARTED:-}" == "true" ]]; then
            log "‚ÑπÔ∏è nm-applet ya fue reiniciado anteriormente, omitiendo paso..."
        else
            # Marcar nm-applet como ya reiniciado
            NM_APPLET_ALREADY_RESTARTED="true"
            
            # M√©todo ultra-r√°pido: matar inmediatamente y reiniciar
            if pgrep -x nm-applet > /dev/null; then
                log "üîÑ Cerrando nm-applet existente..."
                pkill -9 nm-applet 2>/dev/null || true
                sleep 0.2  # Solo 0.2 segundos
            fi
            
            # Iniciar nm-applet inmediatamente con --indicator para m√°xima velocidad
            log "üöÄ Iniciando nm-applet optimizado..."
            nm-applet --indicator > /dev/null 2>&1 &
            nm_pid=$!
            
            # Verificaci√≥n ultra-r√°pida - solo 0.2 segundos total
            sleep 0.2
            
            if pgrep -x nm-applet > /dev/null; then
                log "‚úÖ nm-applet reiniciado r√°pidamente (PID: $nm_pid)"
            else
                log "‚ö†Ô∏è Reintentando nm-applet..."
                nm-applet --indicator &
                sleep 0.3
                pgrep -x nm-applet > /dev/null && log "‚úÖ nm-applet iniciado en segundo intento" || log "‚ùå nm-applet fall√≥"
            fi
        fi
        
        # 9. NUEVO: Sincronizar terminales (Kitty + Oh My Posh + P10k)
        log "üñ•Ô∏è PASO 8: Sincronizando terminales con pywal..."
        
        if [[ -x "$HOME/.local/bin/sync-terminals-pywal" ]]; then
            log "üîÑ Ejecutando sync-terminals-pywal..."
            if "$HOME/.local/bin/sync-terminals-pywal"; then
                log "‚úÖ Terminales sincronizados exitosamente"
            else
                log "‚ö†Ô∏è Advertencia: Error en sync-terminals-pywal"
            fi
        else
            log "‚ö†Ô∏è Script sync-terminals-pywal no encontrado"
            
            # Fallback: sincronizar solo Kitty b√°sicamente
            if [[ -f "$HOME/.cache/wal/colors-kitty.conf" ]]; then
                log "üê± Fallback: Kitty ya tiene colores de pywal"
            fi
        fi
        
        # 10. NUEVO: Sincronizaci√≥n con pywalfox
        log "ü¶ä PASO 9: Sincronizando con pywalfox..."
        
        if command -v pywalfox > /dev/null 2>&1; then
            log "üé® Ejecutando pywalfox update..."
            if pywalfox update > /dev/null 2>&1; then
                log "‚úÖ pywalfox sincronizado exitosamente"
            else
                log "‚ö†Ô∏è Advertencia: Error en pywalfox update"
            fi
        else
            log "‚ö†Ô∏è pywalfox no est√° disponible en PATH"
        fi
        
        # 11. NUEVO: Sincronizaci√≥n autom√°tica con pywal-auto-sync
        log "üîÑ PASO 10: Sincronizando con pywal-auto-sync..."
        
        if [[ -x "$HOME/.local/bin/pywal-auto-sync" ]]; then
            log "üé® Ejecutando pywal-auto-sync sync..."
            if "$HOME/.local/bin/pywal-auto-sync" sync; then
                log "‚úÖ pywal-auto-sync sincronizado exitosamente"
            else
                log "‚ö†Ô∏è Advertencia: Error en pywal-auto-sync"
            fi
        else
            log "‚ö†Ô∏è Script pywal-auto-sync no encontrado en $HOME/.local/bin/"
        fi
        
        # 12. NUEVO: Sincronizaci√≥n de hyprlock con pywal
        log "üîí PASO 11: Sincronizando hyprlock con pywal..."
        
        # Generar colores mejorados para Hyprland/hyprlock
        if [[ -x "$HOME/.local/bin/hyprland-pywal-colors" ]]; then
            log "üé® Generando colores para hyprlock..."
            if "$HOME/.local/bin/hyprland-pywal-colors"; then
                log "‚úÖ Colores de hyprlock generados exitosamente"
                
                # Verificar que el archivo se cre√≥ correctamente
                if [[ -f "$HOME/.cache/wal/colors-hyprland-enhanced.conf" ]]; then
                    log "‚úÖ Archivo colors-hyprland-enhanced.conf confirmado"
                    # Opcional: recargar hyprlock si est√° activo (solo si es necesario)
                    if pgrep -x hyprlock > /dev/null; then
                        log "‚ÑπÔ∏è hyprlock est√° activo, los nuevos colores se aplicar√°n en el pr√≥ximo bloqueo"
                    fi
                else
                    log "‚ö†Ô∏è Advertencia: No se pudo crear colors-hyprland-enhanced.conf"
                fi
            else
                log "‚ö†Ô∏è Advertencia: Error al generar colores para hyprlock"
            fi
        else
            log "‚ö†Ô∏è Script hyprland-pywal-colors no encontrado"
        fi
        
        notify "üé® ¬°Wallpaper y sistema completamente sincronizado!"
        log "üîí hyprlock sincronizado: Los colores se aplicar√°n en el pr√≥ximo bloqueo de pantalla"
        
    else
        log "‚ùå Error: Pywal fall√≥"
        notify "‚ö†Ô∏è Error en pywal - wallpaper aplicado parcialmente"
    fi
else
    log "‚ÑπÔ∏è Pywal no disponible, solo se aplic√≥ el wallpaper"
    notify "‚ÑπÔ∏è Solo wallpaper aplicado (pywal no disponible)"
fi

# VERIFICACI√ìN FINAL DE WAYBAR - OPTIMIZADA
if ! pgrep -x waybar > /dev/null; then
    log "‚ùå CR√çTICO: Waybar no est√° ejecut√°ndose al finalizar. Iniciando respaldo..."
    notify "üîß Iniciando waybar de respaldo..."
    
    # Intentar iniciar waybar de respaldo
    nohup waybar > /dev/null 2>&1 &
    waybar_fallback_pid=$!
    
    # Verificaci√≥n R√ÅPIDA - solo 0.5 segundos
    sleep 0.5
    
    if pgrep -x waybar > /dev/null; then
        log "‚úÖ RESPALDO EXITOSO: Waybar iniciado correctamente (PID: $waybar_fallback_pid)"
        notify "‚úÖ Waybar restaurado exitosamente"
    else
        log "‚ùå FALLO CR√çTICO: No se pudo iniciar waybar incluso con respaldo"
        notify "‚ùå Error cr√≠tico: No se pudo iniciar waybar"
        
        # Intentar un √∫ltimo intento con m√©todo diferente
        log "üîÑ √öLTIMO INTENTO: Intentando con systemctl o m√©todo alternativo..."
        
        # Verificar si hay un servicio de waybar
        if systemctl --user is-active --quiet waybar.service 2>/dev/null; then
            log "üîÑ Reiniciando servicio waybar..."
            systemctl --user restart waybar.service
        else
            log "üîÑ √öltimo intento directo..."
            waybar &
            sleep 1
        fi
        
        # Verificaci√≥n final
        if pgrep -x waybar > /dev/null; then
            log "‚úÖ √öLTIMO INTENTO EXITOSO: Waybar finalmente iniciado"
        else
            log "‚ùå FALLO TOTAL: Waybar no se pudo iniciar. Puede requerir intervenci√≥n manual."
            notify "‚ö†Ô∏è Waybar fall√≥ - inicia manualmente: waybar &"
        fi
    fi
else
    log "‚úÖ VERIFICACI√ìN EXITOSA: Waybar est√° ejecut√°ndose correctamente"
fi

log "üéâ === CAMBIO DE WALLPAPER COMPLETADO ==="
log "üì∏ Wallpaper: $(basename "$selected_file")"
log "üé® Sistema sincronizado exitosamente con waybar reiniciado"

exit 0
