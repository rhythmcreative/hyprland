#!/bin/bash

# Script de sincronizaciÃ³n COMPLETA: Wallpaper + Waybar + Pywal + P10k + nm-applet
# VersiÃ³n mejorada que garantiza la sincronizaciÃ³n de TODOS los componentes
# Ejecutado por: Super + Shift + W en Hyprland

set -euo pipefail

LOG_FILE="$HOME/.cache/complete-wallpaper-sync.log"
LOCK_FILE="/tmp/complete-wallpaper-sync.lock"

# FunciÃ³n de logging con timestamp
log() {
    local message="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    echo "$message" | tee -a "$LOG_FILE"
}

# FunciÃ³n de notificaciÃ³n
notify() {
    notify-send "ğŸ¨ SincronizaciÃ³n Completa" "$1" -t 3000 2>/dev/null || true
}

# Verificar si ya estÃ¡ ejecutÃ¡ndose
if [[ -f "$LOCK_FILE" ]]; then
    lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
        log "â³ SincronizaciÃ³n ya en progreso (PID: $lock_pid)"
        exit 0
    fi
fi

# Crear lock
echo $$ > "$LOCK_FILE"

# Cleanup function
cleanup() {
    rm -f "$LOCK_FILE"
}
trap cleanup EXIT

log "ğŸš€ === INICIANDO SINCRONIZACIÃ“N COMPLETA ==="
notify "Iniciando sincronizaciÃ³n completa..."

# PASO 1: Wallpaper + Pywal (SIN mÃºltiples reinicios de Waybar)
log "ğŸ“¸ PASO 1: Cambiando wallpaper y aplicando Pywal (mÃ©todo seguro)..."
if [[ -x "$HOME/.local/bin/simple-wallpaper-changer" ]]; then
    if "$HOME/.local/bin/simple-wallpaper-changer"; then
        log "âœ… PASO 1 completado: Wallpaper + Pywal sincronizados (sin reiniciar Waybar)"
        sleep 1  # Esperar a que pywal genere todos los archivos
    else
        log "âŒ ERROR en PASO 1: FallÃ³ wallpaper/pywal"
        notify "âŒ Error en wallpaper/pywal"
        exit 1
    fi
else
    log "âš ï¸ Script simple-wallpaper-changer no encontrado, usando mÃ©todo bÃ¡sico..."
    # MÃ©todo bÃ¡sico: solo cambiar wallpaper y aplicar pywal
    WALLPAPER_DIR="$HOME/Pictures/Wallpapers"
    if [[ -d "$WALLPAPER_DIR" ]]; then
        # Seleccionar wallpaper aleatorio como fallback
        current_wallpaper=$(find "$WALLPAPER_DIR" -type f \( -iname "*.jpg" -o -iname "*.png" -o -iname "*.jpeg" \) | shuf -n1)
        if [[ -n "$current_wallpaper" ]]; then
            swww img "$current_wallpaper" --transition-type grow --transition-duration 1.5
            wal -i "$current_wallpaper" -n -q
            echo "$current_wallpaper" > "$HOME/.cache/current-wallpaper"
            log "âœ… PASO 1 completado: Wallpaper bÃ¡sico aplicado"
        fi
    fi
fi

# PASO 2: Powerlevel10k
log "ğŸ¨ PASO 2: Sincronizando Powerlevel10k..."
if [[ -x "$HOME/.local/bin/p10k-auto-sync" ]]; then
    if "$HOME/.local/bin/p10k-auto-sync"; then
        log "âœ… PASO 2 completado: Powerlevel10k sincronizado"
    else
        log "âš ï¸ ADVERTENCIA: FallÃ³ p10k-auto-sync, continuando..."
    fi
else
    log "âš ï¸ ADVERTENCIA: p10k-auto-sync no encontrado, omitiendo..."
fi

# PASO 3: Oh My Posh
log "ğŸµ PASO 3: Sincronizando Oh My Posh..."
if [[ -x "$HOME/.local/bin/sync-omp-pywal" ]]; then
    if "$HOME/.local/bin/sync-omp-pywal"; then
        log "âœ… PASO 3 completado: Oh My Posh sincronizado"
    else
        log "âš ï¸ ADVERTENCIA: FallÃ³ sync-omp-pywal, continuando..."
    fi
else
    log "âš ï¸ ADVERTENCIA: sync-omp-pywal no encontrado, omitiendo..."
fi

# PASO 4: Configurar temas GTK (Arc + Tela circle black) - CRÃTICO DESPUÃ‰S DE PYWAL
log "ğŸ¨ PASO 4: Configurando temas GTK - Arc widgets y Tela circle black icons..."

# Esperar un momento adicional para que pywal termine completamente
sleep 1

# Configurar tema de widgets Arc (FORZAR despuÃ©s de pywal)
log "ğŸ­ Aplicando tema Arc (sobrescribiendo PywalDark)..."
if gsettings set org.gnome.desktop.interface gtk-theme "Arc-Dark" 2>/dev/null; then
    log "âœ… Tema de widgets Arc-Dark aplicado (sobrescribiÃ³ PywalDark)"
    # Verificar que se aplicÃ³ correctamente
    current_gtk_theme=$(gsettings get org.gnome.desktop.interface gtk-theme 2>/dev/null || echo "unknown")
    log "ğŸ“‹ Tema GTK actual: $current_gtk_theme"
else
    log "âš ï¸ Arc-Dark fallÃ³, intentando con Arc..."
    if gsettings set org.gnome.desktop.interface gtk-theme "Arc" 2>/dev/null; then
        log "âœ… Tema de widgets Arc aplicado (sobrescribiÃ³ PywalDark)"
        current_gtk_theme=$(gsettings get org.gnome.desktop.interface gtk-theme 2>/dev/null || echo "unknown")
        log "ğŸ“‹ Tema GTK actual: $current_gtk_theme"
    else
        log "âš ï¸ ADVERTENCIA: No se pudo aplicar tema Arc, manteniÃ©ndose PywalDark"
    fi
fi

# Configurar tema de iconos Tela circle black
log "ğŸ¯ Aplicando iconos Tela circle black..."
if gsettings set org.gnome.desktop.interface icon-theme "Tela-circle-black-dark" 2>/dev/null; then
    log "âœ… Tema de iconos Tela-circle-black-dark aplicado"
    # Verificar que se aplicÃ³ correctamente
    current_icon_theme=$(gsettings get org.gnome.desktop.interface icon-theme 2>/dev/null || echo "unknown")
    log "ğŸ“‹ Tema de iconos actual: $current_icon_theme"
else
    log "âš ï¸ Tela-circle-black-dark fallÃ³, intentando con Tela-circle-black..."
    if gsettings set org.gnome.desktop.interface icon-theme "Tela-circle-black" 2>/dev/null; then
        log "âœ… Tema de iconos Tela-circle-black aplicado"
        current_icon_theme=$(gsettings get org.gnome.desktop.interface icon-theme 2>/dev/null || echo "unknown")
        log "ğŸ“‹ Tema de iconos actual: $current_icon_theme"
    else
        log "âš ï¸ ADVERTENCIA: No se pudo aplicar tema Tela circle black"
    fi
fi

# TambiÃ©n configurar para aplicaciones que usan Qt
if command -v qt5ct >/dev/null 2>&1; then
    export QT_QPA_PLATFORMTHEME=qt5ct
    log "âœ… Variable Qt5ct configurada"
fi

# Configurar variables de entorno adicionales para asegurar consistencia
export GTK_THEME="Arc-Dark"
log "âœ… Variable GTK_THEME=Arc-Dark exportada"

log "ğŸ¨ PASO 4 completado: Temas GTK configurados y verificados"

# PASO 5: Asegurar que Waybar tenga los colores pywal SIN reiniciar
log "ğŸ“± PASO 5: Sincronizando CSS de Waybar de forma segura..."
if pgrep -x waybar > /dev/null; then
    log "âœ… Waybar estÃ¡ corriendo, recargando solo CSS..."
    # Solo recargar CSS con SIGUSR2 (no reinicia el proceso)
    if pkill -USR2 waybar 2>/dev/null; then
        log "âœ… CSS de Waybar recargado exitosamente"
        sleep 1
        # Verificar que waybar sigue funcionando
        if pgrep -x waybar > /dev/null; then
            log "âœ… Waybar verificado - sigue funcionando correctamente"
        else
            log "âš ï¸ Waybar se cerrÃ³ despuÃ©s de recargar CSS, reiniciando..."
            waybar > /dev/null 2>&1 &
            sleep 2
        fi
    else
        log "â„¹ï¸ No se pudo enviar seÃ±al USR2 a Waybar, mantiene configuraciÃ³n anterior"
    fi
else
    log "ğŸš€ Waybar no estÃ¡ corriendo, iniciÃ¡ndolo..."
    waybar > /dev/null 2>&1 &
    sleep 2
fi
log "âœ… PASO 5 completado: Waybar CSS sincronizado de forma segura"

# PASO 5B: nm-applet - PRESERVAR COMPLETAMENTE (no tocar)
log "ğŸ“¶ PASO 5B: Preservando nm-applet intacto..."
log "â„¹ï¸ nm-applet NO se reinicia ni modifica para evitar pÃ©rdida"
log "â„¹ï¸ Los colores de nm-applet se aplicarÃ¡n automÃ¡ticamente via gsettings/dbus"
log "âœ… PASO 5B completado: nm-applet preservado completamente"

# PASO 6: SDDM (opcional)
log "ğŸ” PASO 6: Sincronizando SDDM..."
if [[ -x "$HOME/.local/bin/sddm-auto-sync-complete" ]]; then
    # Ejecutar SDDM sync en segundo plano para no bloquear
    "$HOME/.local/bin/sddm-auto-sync-complete" &
    sddm_pid=$!
    
    # Dar 10 segundos mÃ¡ximo para SDDM
    if timeout 10s wait $sddm_pid 2>/dev/null; then
        log "âœ… PASO 6 completado: SDDM sincronizado"
    else
        log "âš ï¸ SDDM sync continuando en segundo plano..."
        disown $sddm_pid 2>/dev/null || true
    fi
else
    log "â„¹ï¸ SDDM sync no disponible, omitiendo..."
fi

# PASO 7: VerificaciÃ³n final y notificaciÃ³n
log "ğŸ” PASO 7: VerificaciÃ³n final de componentes..."

# Verificar que los componentes crÃ­ticos estÃ©n funcionando
components_ok=true

# Verificar Waybar
if pgrep -x waybar > /dev/null; then
    log "âœ… Waybar estÃ¡ funcionando"
else
    log "âš ï¸ Waybar no estÃ¡ corriendo"
    components_ok=false
fi

# Verificar nm-applet (SOLO VERIFICACIÃ“N - no intentar restaurar)
if pgrep -x nm-applet > /dev/null; then
    log "âœ… nm-applet estÃ¡ funcionando correctamente"
else
    log "â„¹ï¸ nm-applet no estÃ¡ corriendo (esto es normal si el usuario lo detuvo manualmente)"
    log "â„¹ï¸ No se intenta restaurar automÃ¡ticamente para evitar interferencias"
fi

# Verificar archivos pywal
if [[ -f "$HOME/.cache/wal/colors.sh" ]]; then
    log "âœ… Colores pywal disponibles"
else
    log "âš ï¸ Archivos pywal no encontrados"
    components_ok=false
fi

# Verificar temas GTK finales
final_gtk_theme=$(gsettings get org.gnome.desktop.interface gtk-theme 2>/dev/null || echo "'unknown'")
final_icon_theme=$(gsettings get org.gnome.desktop.interface icon-theme 2>/dev/null || echo "'unknown'")

log "ğŸ“‹ VerificaciÃ³n final de temas:"
log "   â€¢ GTK Theme: $final_gtk_theme"
log "   â€¢ Icon Theme: $final_icon_theme"

# Validar si los temas estÃ¡n como esperamos
if [[ "$final_gtk_theme" == "'Arc-Dark'" ]] || [[ "$final_gtk_theme" == "'Arc'" ]]; then
    log "âœ… Tema GTK Arc confirmado"
else
    log "âš ï¸ Tema GTK no es Arc (actual: $final_gtk_theme)"
fi

if [[ "$final_icon_theme" == "'Tela-circle-black-dark'" ]] || [[ "$final_icon_theme" == "'Tela-circle-black'" ]]; then
    log "âœ… Tema de iconos Tela circle black confirmado"
else
    log "âš ï¸ Tema de iconos no es Tela circle black (actual: $final_icon_theme)"
fi

# Resultado final
if $components_ok; then
    log "ğŸ‰ === SINCRONIZACIÃ“N COMPLETA EXITOSA ==="
    notify "ğŸ‰ SincronizaciÃ³n completa exitosa!"
    
    # Mostrar resumen
    current_wallpaper=$(cat "$HOME/.cache/current-wallpaper" 2>/dev/null || echo "Desconocido")
    log "ğŸ“¸ Wallpaper: $(basename "$current_wallpaper")"
    log "ğŸ¨ Todos los componentes sincronizados con pywal"
    log "ğŸ­ Tema GTK: Arc (widgets) + Tela circle black (iconos)"
    log "ğŸ“± Waybar, nm-applet y demÃ¡s componentes funcionando correctamente"
else
    log "âš ï¸ === SINCRONIZACIÃ“N PARCIAL - ALGUNOS COMPONENTES FALLARON ==="
    notify "âš ï¸ SincronizaciÃ³n parcial - revisar logs"
fi

log "ğŸ“‹ Log completo disponible en: $LOG_FILE"
exit 0
