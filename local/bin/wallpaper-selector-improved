#!/bin/bash

# Wallpaper Selector - VersiÃ³n mejorada con previews

# Variables bÃ¡sicas
WALLPAPER_DIR="$HOME/Pictures/Wallpapers"
CACHE_DIR="$HOME/.cache/wallpaper-previews"
TEMP_DIR="/tmp/rofi-wallpaper-$$"

# Crear directorios necesarios
mkdir -p "$CACHE_DIR" "$TEMP_DIR"

# FunciÃ³n para ocultar waybar
hide_waybar() {
    if pgrep -x waybar > /dev/null; then
        pkill -SIGUSR1 waybar 2>/dev/null || true
    fi
}

# FunciÃ³n para mostrar waybar
show_waybar() {
    if pgrep -x waybar > /dev/null; then
        pkill -SIGUSR2 waybar 2>/dev/null || true
    fi
}

# FunciÃ³n simplificada para evitar reinicios mÃºltiples
reload_waybar_safely() {
    # No reiniciar waybar aquÃ­, solo usar el script de sincronizaciÃ³n
    echo "Delegando recarga a waybar-pywal-sync..."
}

# FunciÃ³n para limpiar al salir
cleanup() {
    show_waybar  # Mostrar waybar al salir
    rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

# Verificar directorio
if [[ ! -d "$WALLPAPER_DIR" ]]; then
    notify-send "âŒ Error" "Directorio $WALLPAPER_DIR no encontrado" -u critical
    exit 1
fi

# Verificar dependencias
if ! command -v convert >/dev/null 2>&1; then
    notify-send "âŒ Error" "ImageMagick no estÃ¡ instalado (se requiere 'convert')" -u critical
    exit 1
fi

# Buscar imÃ¡genes
cd "$WALLPAPER_DIR" || exit 1
shopt -s nullglob
images=(*.{jpg,jpeg,png,gif,webp,bmp})

# Verificar que hay imÃ¡genes
if [[ ${#images[@]} -eq 0 ]]; then
    notify-send "âŒ Error" "No se encontraron imÃ¡genes vÃ¡lidas" -u critical
    exit 1
fi

# Generar lista para rofi con mejor formato
options=""
valid_images=()

for img in "${images[@]}"; do
    # Verificar que el archivo existe
    [[ ! -f "$img" ]] && continue
    
    clean_name="${img%.*}"
    preview_file="$CACHE_DIR/preview_${clean_name}.png"
    
    # Generar preview si no existe
    if [[ ! -f "$preview_file" ]]; then
        echo "Generando preview para: $img"
        if [[ "$img" == *.gif ]]; then
            convert "$img[0]" -resize "200x150^" -gravity center -extent "200x150" "$preview_file" 2>/dev/null
        else
            convert "$img" -resize "200x150^" -gravity center -extent "200x150" "$preview_file" 2>/dev/null
        fi
    fi
    
    # Si se generÃ³ el preview correctamente, agregarlo
    if [[ -f "$preview_file" ]]; then
        valid_images+=("$img")
        options+="$clean_name\0icon\x1f$preview_file\n"
    fi
done

# Si no hay opciones vÃ¡lidas, salir
if [[ ${#valid_images[@]} -eq 0 ]]; then
    notify-send "âŒ Error" "No se pudieron generar previews vÃ¡lidos" -u critical
    exit 1
fi

# Crear archivo temporal para rofi
options_file="$TEMP_DIR/options"
printf "$options" > "$options_file"

# Usar el tema de HyprNova
theme_file="$HOME/HyprNova/.config/rofi/themes/wallpaper-select.rasi"

# Ocultar waybar antes de mostrar el selector
hide_waybar

# Mostrar selector con rofi
selected=$(cat "$options_file" | rofi -dmenu -i \
    -theme "$theme_file" \
    -p "ðŸ–¼ï¸ Seleccionar Wallpaper" \
    -show-icons \
    -markup-rows \
    -no-custom)

# Si no se seleccionÃ³ nada, salir
[[ -z "$selected" ]] && exit 0

# Buscar el archivo correspondiente
selected_file=""
for img in "${valid_images[@]}"; do
    if [[ "${img%.*}" == "$selected" ]]; then
        selected_file="$WALLPAPER_DIR/$img"
        break
    fi
done

# Verificar que se encontrÃ³ el archivo
if [[ -z "$selected_file" ]] || [[ ! -f "$selected_file" ]]; then
    notify-send "âŒ Error" "Archivo no encontrado: $selected" -u critical
    exit 1
fi

# Aplicar wallpaper
notify-send "ðŸŽ¨ Aplicando Wallpaper" "$selected" -t 2000
swww img "$selected_file" --transition-type grow --transition-pos "0.9,0.1" --transition-duration 1.5
# Guardar wallpaper actual para referencia futura
echo "$selected_file" > ~/.cache/current-wallpaper

# Aplicar pywal si estÃ¡ disponible
if command -v wal > /dev/null 2>&1; then
    notify-send "ðŸŽ¨ Aplicando colores..." "Generando tema con pywal" -t 1500
    
    # Para GIFs, extraer primer frame para pywal
    if [[ "${selected_file,,}" == *.gif ]]; then
        # Crear archivo temporal para el primer frame del GIF
        gif_frame_temp="/tmp/gif_frame_for_wal_$$.png"
        
        # Extraer primer frame del GIF
        if convert "$selected_file[0]" "$gif_frame_temp" 2>/dev/null; then
            # Aplicar pywal usando el primer frame
            wal -i "$gif_frame_temp" -n
            
            # Limpiar archivo temporal
            rm -f "$gif_frame_temp" 2>/dev/null || true
            
            notify-send "ðŸŽ¬ GIF + Pywal" "Colores extraÃ­dos del primer frame del GIF" -t 2000
        else
            # Si falla la extracciÃ³n, usar una imagen estÃ¡tica como fallback
            notify-send "âš ï¸ Advertencia" "No se pudo extraer frame del GIF, usando colores previos" -t 2000
        fi
    else
        # Para imÃ¡genes estÃ¡ticas, aplicar pywal normalmente
        wal -i "$selected_file" -n
    fi
    
    # Esperar un momento para que pywal genere los archivos
    sleep 1
    
    # Recargar hyprland para aplicar los nuevos colores
    if [[ -f ~/.cache/wal/colors-hyprland.conf ]]; then
        hyprctl reload > /dev/null 2>&1 || true
        sleep 0.5
    fi
fi

# La sincronizaciÃ³n de waybar con pywal se harÃ¡ despuÃ©s con waybar-pywal-sync
echo "Wallpaper aplicado - sincronizaciÃ³n waybar pendiente..."

# Para GIFs, asegurar que swww mantiene la animaciÃ³n despuÃ©s de recargar hyprland
if [[ "${selected_file,,}" == *.gif ]]; then
    sleep 1
    # Verificar que swww-daemon sigue corriendo
    if ! pgrep -x "swww-daemon" > /dev/null; then
        swww-daemon --format xrgb &
        sleep 2
    fi
    # Reaplicar el GIF para asegurar animaciÃ³n
    swww img "$selected_file" --transition-type none --transition-duration 0.1 > /dev/null 2>&1 || true
fi

notify-send "âœ… Completado" "Wallpaper y tema aplicados, waybar reiniciado" -t 2000
